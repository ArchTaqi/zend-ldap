{
    "docs": [
        {
            "location": "/", 
            "text": "../../README.md", 
            "title": "Home"
        }, 
        {
            "location": "/intro/", 
            "text": "Introduction\n\n\nzend-ldap lets you perform LDAP operations, including, but not limited to,\nbinding, searching and modifying entries in an LDAP directory.\n\n\nTheory of operation\n\n\nThis component currently consists of the main \nZend\\Ldap\\Ldap\n class, which\nconceptually represents a binding to a single LDAP server and allows for\nexecuting operations against a LDAP server such as OpenLDAP or ActiveDirectory\n(AD) servers. The parameters for binding may be provided explicitly or in the\nform of an options array. \nZend\\Ldap\\Node\n provides an object-oriented interface\nfor single LDAP nodes and can be used to form a basis for an active-record-like\ninterface for a LDAP-based domain model.\n\n\nThe component provides several helper classes to perform operations on LDAP\nentries (\nZend\\Ldap\\Attribute\n) such as setting and retrieving attributes (date\nvalues, passwords, boolean values, ...), to create and modify LDAP filter\nstrings (\nZend\\Ldap\\Filter\n) and to manipulate LDAP distinguished names (DN)\n(\nZend\\Ldap\\Dn\n).\n\n\nAdditionally the component abstracts LDAP schema browsing for OpenLDAP and\nActiveDirectory servers \nZend\\Ldap\\Node\\Schema\n and server information retrieval\nfor OpenLDAP-, ActiveDirectory- and Novell eDirectory servers\n(\nZend\\Ldap\\Node\\RootDse\n).\n\n\nUsage of zend-ldap depends on the type of LDAP server, and is best summarized with\nsome examples.\n\n\nIf you are using OpenLDAP, consider the following example (note that the\n\nbindRequiresDn\n option is important if you are \nnot\n using AD):\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [\n    'host'              =\n 's0.foo.net',\n    'username'          =\n 'CN=user1,DC=foo,DC=net',\n    'password'          =\n 'pass1',\n    'bindRequiresDn'    =\n true,\n    'accountDomainName' =\n 'foo.net',\n    'baseDn'            =\n 'OU=Sales,DC=foo,DC=net',\n];\n\n$ldap = new Ldap($options);\n$acctname = $ldap-\ngetCanonicalAccountName('abaker', Ldap::ACCTNAME_FORM_DN);\necho \n$acctname\\n\n;\n\n\n\nIf you are using Microsoft AD:\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [\n    'host'                   =\n 'dc1.w.net',\n    'useStartTls'            =\n true,\n    'username'               =\n 'user1@w.net',\n    'password'               =\n 'pass1',\n    'accountDomainName'      =\n 'w.net',\n    'accountDomainNameShort' =\n 'W',\n    'baseDn'                 =\n 'CN=Users,DC=w,DC=net',\n];\n\n$ldap = new Ldap($options);\n$acctname = $ldap-\ngetCanonicalAccountName('bcarter', Ldap::ACCTNAME_FORM_DN);\necho \n$acctname\\n\n;\n\n\n\nNote that we use the \ngetCanonicalAccountName()\n method to retrieve the account\nDN here only because that is what exercises the most of what little code is\ncurrently present in this class.\n\n\nAutomatic Username Canonicalization When Binding\n\n\nIf \nbind()\n is called with a non-DN username but \nbindRequiresDN\n is \ntrue\n\nand no username in DN form was supplied as an option, the bind will fail.\nHowever, if a username in DN form is supplied in the options array,\n\nZend\\Ldap\\Ldap\n will first bind with that username, retrieve the account DN for\nthe username supplied to \nbind()\n and then re-bind with that DN.\n\n\nThis behavior is critical to \nZend\\Authentication\\Adapter\\Ldap\n,\nwhich passes the username supplied by the user directly to \nbind()\n.\n\n\nThe following example illustrates how the non-DN username 'abaker' can be used\nwith \nbind()\n:\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [\n    'host'              =\n 's0.foo.net',\n    'username'          =\n 'CN=user1,DC=foo,DC=net',\n    'password'          =\n 'pass1',\n    'bindRequiresDn'    =\n true,\n    'accountDomainName' =\n 'foo.net',\n    'baseDn'            =\n 'OU=Sales,DC=foo,DC=net',\n];\n\n$ldap = new Ldap($options);\n$ldap-\nbind('abaker', 'moonbike55');\n$acctname = $ldap-\ngetCanonicalAccountName('abaker', Ldap::ACCTNAME_FORM_DN);\necho \n$acctname\\n\n;\n\n\n\nThe \nbind()\n call in this example sees that the username 'abaker' is not in DN\nform, finds \nbindRequiresDn\n is \nTRUE\n, uses \nCN=user1,DC=foo,DC=net\n and\n\npass1\n to bind, retrieves the DN for 'abaker', unbinds and then rebinds with\nthe newly discovered \nCN=Alice Baker,OU=Sales,DC=foo,DC=net\n.\n\n\nAccount Name Canonicalization\n\n\nThe \naccountDomainName\n and \naccountDomainNameShort\n options are used for two\npurposes: (1) they facilitate multi-domain authentication and failover\ncapability, and (2) they are also used to canonicalize usernames. Specifically,\nnames are canonicalized to the form specified by the \naccountCanonicalForm\n\noption. This option may one of the following values:\n\n\nThe default canonicalization depends on what account domain name options were\nsupplied. If \naccountDomainNameShort\n was supplied, the default\n\naccountCanonicalForm\n value is \nACCTNAME_FORM_BACKSLASH\n. Otherwise, if\n\naccountDomainName\n was supplied, the default is \nACCTNAME_FORM_PRINCIPAL\n.\n\n\nAccount name canonicalization ensures that the string used to identify an\naccount is consistent regardless of what was supplied to \nbind()\n. For example,\nif the user supplies an account name of \nabaker@example.com\n or just \nabaker\n\nand the \naccountCanonicalForm\n is set to 3, the resulting canonicalized name\nwould be \nEXAMPLE\\\\abaker\n.\n\n\nMulti-domain Authentication and Failover\n\n\nThe \nZend\\Ldap\\Ldap\n component by itself makes no attempt to authenticate with\nmultiple servers.  However, \nZend\\Ldap\\Ldap\n is specifically designed to handle\nthis scenario gracefully. The required technique is to simply iterate over an\narray of arrays of serve options and attempt to bind with each server. As\ndescribed above \nbind()\n will automatically canonicalize each name, so it does\nnot matter if the user passes \nabaker@foo.net\n or \nWbcarter\n or \ncdavis\n; the\n\nbind()\n method will only succeed if the credentials were successfully used in\nthe bind.\n\n\nConsider the following example that illustrates the technique required to\nimplement multi-domain authentication and failover:\n\n\nuse Zend\\Ldap\\Exception\\LdapException;\nuse Zend\\Ldap\\Ldap;\n\n$acctname = 'W\\\\user2';\n$password = 'pass2';\n\n$multiOptions = [\n    'server1' =\n [\n        'host'                   =\n 's0.foo.net',\n        'username'               =\n 'CN=user1,DC=foo,DC=net',\n        'password'               =\n 'pass1',\n        'bindRequiresDn'         =\n true,\n        'accountDomainName'      =\n 'foo.net',\n        'accountDomainNameShort' =\n 'FOO',\n        'accountCanonicalForm'   =\n 4, // ACCT_FORM_PRINCIPAL\n        'baseDn'                 =\n 'OU=Sales,DC=foo,DC=net',\n    ],\n    'server2' =\n [\n        'host'                   =\n 'dc1.w.net',\n        'useSsl'                 =\n true,\n        'username'               =\n 'user1@w.net',\n        'password'               =\n 'pass1',\n        'accountDomainName'      =\n 'w.net',\n        'accountDomainNameShort' =\n 'W',\n        'accountCanonicalForm'   =\n 4, // ACCT_FORM_PRINCIPAL\n        'baseDn'                 =\n 'CN=Users,DC=w,DC=net',\n    ],\n];\n\n$ldap = new Ldap();\n\nforeach ($multiOptions as $name =\n $options) {\n    echo \nTrying to bind using server options for '$name'\\n\n;\n\n    $ldap-\nsetOptions($options);\n    try {\n        $ldap-\nbind($acctname, $password);\n        $acctname = $ldap-\ngetCanonicalAccountName($acctname);\n        echo \nSUCCESS: authenticated $acctname\\n\n;\n        return;\n    } catch (LdapException $zle) {\n        echo '  ' . $zle-\ngetMessage() . \n\\n\n;\n        if ($zle-\ngetCode() === LdapException::LDAP_X_DOMAIN_MISMATCH) {\n            continue;\n        }\n    }\n}\n\n\n\nIf the bind fails for any reason, the next set of server options is tried.\n\n\nThe \ngetCanonicalAccountName()\n call gets the canonical account name that the\napplication would presumably use to associate data with such as preferences. The\n\naccountCanonicalForm = 4\n in all server options ensures that the canonical form\nis consistent regardless of which server was ultimately used.\n\n\nThe special \nLDAP_X_DOMAIN_MISMATCH\n exception occurs when an account name with\na domain component was supplied (e.g., \nabaker@foo.net\n or \nFOO\\\\abaker\n and not\njust \nabaker\n) but the domain component did not match either domain in the\ncurrently selected server options. This exception indicates that the server is\nnot an authority for the account. In this case, the bind will not be performed,\nthereby eliminating unnecessary communication with the server. Note that the\n\ncontinue\n instruction has no effect in this example, but in practice for error\nhandling and debugging purposes, you will probably want to check for\n\nLDAP_X_DOMAIN_MISMATCH\n as well as \nLDAP_NO_SUCH_OBJECT\n and\n\nLDAP_INVALID_CREDENTIALS\n.\n\n\nThe above code is very similar to code used within\n\nZend\\Authentication\\Adapter\\Ldap\n.\nIn fact,we recommend that you use that authentication adapter for multi-domain +\nfailover LDAP based authentication (or copy the code).", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#introduction", 
            "text": "zend-ldap lets you perform LDAP operations, including, but not limited to,\nbinding, searching and modifying entries in an LDAP directory.", 
            "title": "Introduction"
        }, 
        {
            "location": "/intro/#theory-of-operation", 
            "text": "This component currently consists of the main  Zend\\Ldap\\Ldap  class, which\nconceptually represents a binding to a single LDAP server and allows for\nexecuting operations against a LDAP server such as OpenLDAP or ActiveDirectory\n(AD) servers. The parameters for binding may be provided explicitly or in the\nform of an options array.  Zend\\Ldap\\Node  provides an object-oriented interface\nfor single LDAP nodes and can be used to form a basis for an active-record-like\ninterface for a LDAP-based domain model.  The component provides several helper classes to perform operations on LDAP\nentries ( Zend\\Ldap\\Attribute ) such as setting and retrieving attributes (date\nvalues, passwords, boolean values, ...), to create and modify LDAP filter\nstrings ( Zend\\Ldap\\Filter ) and to manipulate LDAP distinguished names (DN)\n( Zend\\Ldap\\Dn ).  Additionally the component abstracts LDAP schema browsing for OpenLDAP and\nActiveDirectory servers  Zend\\Ldap\\Node\\Schema  and server information retrieval\nfor OpenLDAP-, ActiveDirectory- and Novell eDirectory servers\n( Zend\\Ldap\\Node\\RootDse ).  Usage of zend-ldap depends on the type of LDAP server, and is best summarized with\nsome examples.  If you are using OpenLDAP, consider the following example (note that the bindRequiresDn  option is important if you are  not  using AD):  use Zend\\Ldap\\Ldap;\n\n$options = [\n    'host'              =  's0.foo.net',\n    'username'          =  'CN=user1,DC=foo,DC=net',\n    'password'          =  'pass1',\n    'bindRequiresDn'    =  true,\n    'accountDomainName' =  'foo.net',\n    'baseDn'            =  'OU=Sales,DC=foo,DC=net',\n];\n\n$ldap = new Ldap($options);\n$acctname = $ldap- getCanonicalAccountName('abaker', Ldap::ACCTNAME_FORM_DN);\necho  $acctname\\n ;  If you are using Microsoft AD:  use Zend\\Ldap\\Ldap;\n\n$options = [\n    'host'                   =  'dc1.w.net',\n    'useStartTls'            =  true,\n    'username'               =  'user1@w.net',\n    'password'               =  'pass1',\n    'accountDomainName'      =  'w.net',\n    'accountDomainNameShort' =  'W',\n    'baseDn'                 =  'CN=Users,DC=w,DC=net',\n];\n\n$ldap = new Ldap($options);\n$acctname = $ldap- getCanonicalAccountName('bcarter', Ldap::ACCTNAME_FORM_DN);\necho  $acctname\\n ;  Note that we use the  getCanonicalAccountName()  method to retrieve the account\nDN here only because that is what exercises the most of what little code is\ncurrently present in this class.", 
            "title": "Theory of operation"
        }, 
        {
            "location": "/intro/#automatic-username-canonicalization-when-binding", 
            "text": "If  bind()  is called with a non-DN username but  bindRequiresDN  is  true \nand no username in DN form was supplied as an option, the bind will fail.\nHowever, if a username in DN form is supplied in the options array, Zend\\Ldap\\Ldap  will first bind with that username, retrieve the account DN for\nthe username supplied to  bind()  and then re-bind with that DN.  This behavior is critical to  Zend\\Authentication\\Adapter\\Ldap ,\nwhich passes the username supplied by the user directly to  bind() .  The following example illustrates how the non-DN username 'abaker' can be used\nwith  bind() :  use Zend\\Ldap\\Ldap;\n\n$options = [\n    'host'              =  's0.foo.net',\n    'username'          =  'CN=user1,DC=foo,DC=net',\n    'password'          =  'pass1',\n    'bindRequiresDn'    =  true,\n    'accountDomainName' =  'foo.net',\n    'baseDn'            =  'OU=Sales,DC=foo,DC=net',\n];\n\n$ldap = new Ldap($options);\n$ldap- bind('abaker', 'moonbike55');\n$acctname = $ldap- getCanonicalAccountName('abaker', Ldap::ACCTNAME_FORM_DN);\necho  $acctname\\n ;  The  bind()  call in this example sees that the username 'abaker' is not in DN\nform, finds  bindRequiresDn  is  TRUE , uses  CN=user1,DC=foo,DC=net  and pass1  to bind, retrieves the DN for 'abaker', unbinds and then rebinds with\nthe newly discovered  CN=Alice Baker,OU=Sales,DC=foo,DC=net .", 
            "title": "Automatic Username Canonicalization When Binding"
        }, 
        {
            "location": "/intro/#account-name-canonicalization", 
            "text": "The  accountDomainName  and  accountDomainNameShort  options are used for two\npurposes: (1) they facilitate multi-domain authentication and failover\ncapability, and (2) they are also used to canonicalize usernames. Specifically,\nnames are canonicalized to the form specified by the  accountCanonicalForm \noption. This option may one of the following values:  The default canonicalization depends on what account domain name options were\nsupplied. If  accountDomainNameShort  was supplied, the default accountCanonicalForm  value is  ACCTNAME_FORM_BACKSLASH . Otherwise, if accountDomainName  was supplied, the default is  ACCTNAME_FORM_PRINCIPAL .  Account name canonicalization ensures that the string used to identify an\naccount is consistent regardless of what was supplied to  bind() . For example,\nif the user supplies an account name of  abaker@example.com  or just  abaker \nand the  accountCanonicalForm  is set to 3, the resulting canonicalized name\nwould be  EXAMPLE\\\\abaker .", 
            "title": "Account Name Canonicalization"
        }, 
        {
            "location": "/intro/#multi-domain-authentication-and-failover", 
            "text": "The  Zend\\Ldap\\Ldap  component by itself makes no attempt to authenticate with\nmultiple servers.  However,  Zend\\Ldap\\Ldap  is specifically designed to handle\nthis scenario gracefully. The required technique is to simply iterate over an\narray of arrays of serve options and attempt to bind with each server. As\ndescribed above  bind()  will automatically canonicalize each name, so it does\nnot matter if the user passes  abaker@foo.net  or  Wbcarter  or  cdavis ; the bind()  method will only succeed if the credentials were successfully used in\nthe bind.  Consider the following example that illustrates the technique required to\nimplement multi-domain authentication and failover:  use Zend\\Ldap\\Exception\\LdapException;\nuse Zend\\Ldap\\Ldap;\n\n$acctname = 'W\\\\user2';\n$password = 'pass2';\n\n$multiOptions = [\n    'server1' =  [\n        'host'                   =  's0.foo.net',\n        'username'               =  'CN=user1,DC=foo,DC=net',\n        'password'               =  'pass1',\n        'bindRequiresDn'         =  true,\n        'accountDomainName'      =  'foo.net',\n        'accountDomainNameShort' =  'FOO',\n        'accountCanonicalForm'   =  4, // ACCT_FORM_PRINCIPAL\n        'baseDn'                 =  'OU=Sales,DC=foo,DC=net',\n    ],\n    'server2' =  [\n        'host'                   =  'dc1.w.net',\n        'useSsl'                 =  true,\n        'username'               =  'user1@w.net',\n        'password'               =  'pass1',\n        'accountDomainName'      =  'w.net',\n        'accountDomainNameShort' =  'W',\n        'accountCanonicalForm'   =  4, // ACCT_FORM_PRINCIPAL\n        'baseDn'                 =  'CN=Users,DC=w,DC=net',\n    ],\n];\n\n$ldap = new Ldap();\n\nforeach ($multiOptions as $name =  $options) {\n    echo  Trying to bind using server options for '$name'\\n ;\n\n    $ldap- setOptions($options);\n    try {\n        $ldap- bind($acctname, $password);\n        $acctname = $ldap- getCanonicalAccountName($acctname);\n        echo  SUCCESS: authenticated $acctname\\n ;\n        return;\n    } catch (LdapException $zle) {\n        echo '  ' . $zle- getMessage() .  \\n ;\n        if ($zle- getCode() === LdapException::LDAP_X_DOMAIN_MISMATCH) {\n            continue;\n        }\n    }\n}  If the bind fails for any reason, the next set of server options is tried.  The  getCanonicalAccountName()  call gets the canonical account name that the\napplication would presumably use to associate data with such as preferences. The accountCanonicalForm = 4  in all server options ensures that the canonical form\nis consistent regardless of which server was ultimately used.  The special  LDAP_X_DOMAIN_MISMATCH  exception occurs when an account name with\na domain component was supplied (e.g.,  abaker@foo.net  or  FOO\\\\abaker  and not\njust  abaker ) but the domain component did not match either domain in the\ncurrently selected server options. This exception indicates that the server is\nnot an authority for the account. In this case, the bind will not be performed,\nthereby eliminating unnecessary communication with the server. Note that the continue  instruction has no effect in this example, but in practice for error\nhandling and debugging purposes, you will probably want to check for LDAP_X_DOMAIN_MISMATCH  as well as  LDAP_NO_SUCH_OBJECT  and LDAP_INVALID_CREDENTIALS .  The above code is very similar to code used within Zend\\Authentication\\Adapter\\Ldap .\nIn fact,we recommend that you use that authentication adapter for multi-domain +\nfailover LDAP based authentication (or copy the code).", 
            "title": "Multi-domain Authentication and Failover"
        }, 
        {
            "location": "/api/", 
            "text": "API overview\n\n\nConfiguration options\n\n\nZend\\Ldap\\Ldap\n accepts an array of options either supplied to the constructor\nor through the \nsetOptions()\n method. The permitted options are as follows:\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhost\n\n\nThe default hostname of the LDAP server if not supplied to \nconnect()\n (also may be used when trying to canonicalize usernames in bind()).\n\n\n\n\n\n\nport\n\n\nDefault port of the LDAP server if not supplied to \nconnect()\n.\n\n\n\n\n\n\nuseStartTls\n\n\nWhether or not the LDAP client should use TLS (aka SSLv2) encrypted transport. A value of \ntrue\n is strongly favored in production environments to prevent passwords from be transmitted in clear text. The default value is \nfalse\n, as servers frequently require that a certificate be installed separately after installation. The \nuseSsl\n and \nuseStartTls\n options are mutually exclusive. The \nuseStartTls\n option should be favored over \nuseSsl\n, but not all servers support this newer mechanism.\n\n\n\n\n\n\nuseSsl\n\n\nWhether or not the LDAP client should use SSL encrypted transport. The \nuseSsl\n and \nuseStartTls\n options are mutually exclusive.\n\n\n\n\n\n\nusername\n\n\nThe default credentials username. Some servers require that this be in DN form. This must be given in DN form if the LDAP server requires a DN to bind and binding should be possible with simple usernames.\n\n\n\n\n\n\npassword\n\n\nThe default credentials password (used only with username above).\n\n\n\n\n\n\nbindRequiresDn\n\n\nIf \ntrue\n, this instructs \nZend\\Ldap\\Ldap\n to retrieve the DN for the account used to bind if the username is not already in DN form. The default value is \nfalse\n.\n\n\n\n\n\n\nbaseDn\n\n\nThe default base DN used for searching (e.g., for accounts). This option is required for most account related operations and should indicate the DN under which accounts are located.\n\n\n\n\n\n\naccountCanonicalForm\n\n\nA small integer indicating the form to which account names should be canonicalized. See the \nAccount Name Canonicalization section\n.\n\n\n\n\n\n\naccountDomainName\n\n\nThe FQDN domain for which the target LDAP server is an authority (e.g., \nexample.com\n).\n\n\n\n\n\n\naccountDomainNameShort\n\n\nThe \u2018short\u2019 domain for which the target LDAP server is an authority. This is usually used to specify the NetBIOS domain name for Windows networks, but may also be used by non-AD servers.\n\n\n\n\n\n\naccountFilterFormat\n\n\nThe LDAP search filter used to search for accounts. This string is a \nsprintf()\n style expression that must contain one \n%s\n to accommodate the username. The default value is \n(\n(objectClass=user)(sAMAccountName=%s))\n unless \nbindRequiresDn\n is set to \ntrue\n, in which case the default is \n(\n(objectClass=posixAccount)(uid=%s))\n. Users of custom schemas may need to change this option.\n\n\n\n\n\n\nallowEmptyPassword\n\n\nSome LDAP servers can be configured to accept an empty string password as an anonymous bind. This behavior is almost always undesirable. For this reason, empty passwords are explicitly disallowed. Set this value to \ntrue\n to allow an empty string password to be submitted during the bind.\n\n\n\n\n\n\noptReferrals\n\n\nIf set to \ntrue\n, this option indicates to the LDAP client that referrals should be followed. The default value is \nfalse\n.\n\n\n\n\n\n\ntryUsernameSplit\n\n\nIf set to \nfalse\n, this option indicates that the given username should not be split at the first \n@\n or \n\\\\\n character to separate the username from the domain during the binding-procedure. This allows the user to use usernames that contain an \n@\n or \n\\\\\n character that do not inherit some domain-information, e.g. using email-addresses for binding. The default value is \ntrue\n.\n\n\n\n\n\n\nnetworkTimeout\n\n\nNumber of seconds to wait for LDAP connection before fail. If not set, the default value is the system value.\n\n\n\n\n\n\n\n\nAPI Reference\n\n\nClass names are relative to the \nZend\\Ldap\n namespace, unless otherwise noted.\n\n\nZend\\Ldap\\Ldap\n\n\nZend\\Ldap\\Ldap\n is the base interface into a LDAP server. It provides connection and binding\nmethods as well as methods to operate on the LDAP tree.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__construct(array|Traversable $options = null) : void\n\n\nIf no options are provided at instantiation, the connection parameters must be passed to the instance using \nsetOptions()\n. The allowed options are specified in the \noptions section\n.\n\n\n\n\n\n\ngetResource() : resource\n\n\nReturns the raw LDAP extension (ext/ldap) resource.\n\n\n\n\n\n\ngetLastErrorCode() : int\n\n\nReturns the LDAP error number of the last LDAP command.\n\n\n\n\n\n\ngetLastError(int \n$errorCode = null, array \n$errorMessages = null) : string\n\n\nReturns the LDAP error message of the last LDAP command. The optional \n$errorCode\n parameter is set to the LDAP error number when given. The optional \n$errorMessages\n array will be filled with the raw error messages when given. The various LDAP error retrieval functions can return different things, so they are all collected if \n$errorMessages\n is given.\n\n\n\n\n\n\nsetOptions(array|Traversable $options) : void\n\n\nSets the LDAP connection and binding parameters. Allowed options are specified in the \noptions section\n.\n\n\n\n\n\n\ngetOptions() : array\n\n\nReturns the current connection and binding parameters.\n\n\n\n\n\n\ngetBaseDn() : string\n\n\nReturns the base DN this LDAP connection is bound to.\n\n\n\n\n\n\ngetCanonicalAccountName(string $acctname, int $form) : string\n\n\nReturns the canonical account name of the given account name \n$acctname\n. \n$form\n specifies the format into which the account name is canonicalized. See \nAccount Name Canonicalization\n for more details.\n\n\n\n\n\n\ndisconnect() : void\n\n\nDisconnects the instance from the LDAP server.\n\n\n\n\n\n\nconnect(string $host, int $port, bool $useSsl, bool $useStartTls, int $networkTimeout) : void\n\n\nConnects the instance to the given LDAP server. All parameters are optional and will be taken from the LDAP connection and binding parameters passed to the instance via the constructor or via \nsetOptions()\n if \nnull\n.\n\n\n\n\n\n\nbind(string $username, string $password) : void\n\n\nAuthenticates \n$username\n with \n$password\n on the LDAP server. If both parameters are omitted, the binding will be carried out with the credentials given in the connection and binding parameters. If no credentials are given in the connection and binding parameters, an anonymous bind will be performed. Note that this requires anonymous binds to be allowed on the LDAP server. An empty string, \n''\n, can be passed as \n$password\n together with a username if, and only if, \nallowEmptyPassword\n is set to \ntrue\n in the connection and binding parameters.\n\n\n\n\n\n\nsearch(/* ... */) : Collection\n\n\nSearches the LDAP tree with the given \n$filter\n and the given search parameters; see below for full details.\n\n\n\n\n\n\ncount(string|Filter\\AbstractFilter $filter, string|Dn $basedn, int $scope) : int\n\n\nCounts the elements returned by the given search parameters. See \nsearch()\n for a detailed description of the method parameters.\n\n\n\n\n\n\ncountChildren(string|Dn $dn) : int\n\n\nCounts the direct descendants (children) of the entry identified by the given \n$dn\n.\n\n\n\n\n\n\nexists(string|Dn $dn) : bool\n\n\nChecks whether the entry identified by the given \n$dn\n exists.\n\n\n\n\n\n\nsearchEntries(/* ... */) : array\n\n\nPerforms a search operation and returns the result as an PHP array. This is essentially the same method as \nsearch()\n except for the return type. See \nsearch()\n and \nsearchEntries()\n below for more details.\n\n\n\n\n\n\ngetEntry(string|Dn $dn, array $attributes, bool $throwOnNotFound) : array\n\n\nRetrieves the LDAP entry identified by \n$dn\n with the attributes specified in \n$attributes\n. if \n$attributes\n is omitted, all attributes (\n[]\n) are included in the result. \n$throwOnNotFound\n is \nfalse\n by default, so the method will return \nnull\n if the specified entry cannot be found. If set to \ntrue\n, a \nZend\\Ldap\\Exception\\LdapException\n will be thrown instead.\n\n\n\n\n\n\nprepareLdapEntryArray(array \n$entry) : void\n\n\nPrepare an array for the use in LDAP modification operations. This method does not need to be called by the end-user as it's implicitly called on every data modification method.\n\n\n\n\n\n\nadd(string|Dn $dn, array $entry) : void\n\n\nAdds the entry identified by \n$dn\n with its attributes \n$entry\n to the LDAP tree. Throws a \nZend\\Ldap\\Exception\\LdapException\n if the entry could not be added.\n\n\n\n\n\n\nupdate(string|Dn $dn, array $entry) : void\n\n\nUpdates the entry identified by \n$dn\n with its attributes \n$entry\n to the LDAP tree. Throws a \nZend\\Ldap\\Exception\\LdapException\n if the entry could not be modified.\n\n\n\n\n\n\nsave(string|Dn $dn, array $entry) : void\n\n\nSaves the entry identified by \n$dn\n with its attributes $entry to the LDAP tree. Throws a \nZend\\Ldap\\Exception\\LdapException\n if the entry could not be saved. This method decides by querying the LDAP tree if the entry will be added or updated.\n\n\n\n\n\n\ndelete(string|Dn $dn, boolean $recursively) : void\n\n\nDeletes the entry identified by \n$dn\n from the LDAP tree. Throws a \nZend\\Ldap\\Exception\\LdapException\n if the entry could not be deleted. \n$recursively\n is \nfalse\n by default. If set to \ntrue\n the deletion will be carried out recursively and will effectively delete a complete subtree. Deletion will fail if $recursively is \nfalse\n and the entry \n$dn\n is not a leaf entry.\n\n\n\n\n\n\nmoveToSubtree(string|Dn $from, string|Dn $to, bool $recursively, bool $alwaysEmulate) : void\n\n\nMoves the entry identified by \n$from\n to a location below \n$to\n keeping its RDN unchanged. \n$recursively\n specifies if the operation will be carried out recursively (\nfalse\n by default) so that the entry \n$from\n and all its descendants will be moved. Moving will fail if \n$recursively\n is \nfalse\n and the entry \n$from\n is not a leaf entry. \n$alwaysEmulate\n controls whether the ext/ldap function \nldap_rename()\n should be used if available. This can only work for leaf entries and for servers and for ext/ldap supporting this function. Set to \ntrue\n to always use an emulated rename operation. All move-operations are carried out by copying and then deleting the corresponding entries in the LDAP tree. These operations are not atomic so that failures during the operation will result in an inconsistent state on the LDAP server. The same is true for all recursive operations. They also are by no means atomic. Please keep this in mind.\n\n\n\n\n\n\nmove(string|Dn $from, string|Dn $to, bool $recursively, bool $alwaysEmulate) : void\n\n\nThis is an alias for \nrename()\n.\n\n\n\n\n\n\nrename(string|Dn $from, string|Dn $to, bool $recursively, bool $alwaysEmulate) : void\n\n\nRenames the entry identified by \n$from\n to \n$to\n. \n$recursively\n specifies if the operation will be carried out recursively (\nfalse\n by default) so that the entry \n$from\n and all its descendants will be moved. Moving will fail if \n$recursively\n is \nfalse\n and the entry \n$from\n is not a leaf entry. \n$alwaysEmulate\n controls whether the ext/ldap function \nldap_rename()\n should be used if available. This can only work for leaf entries and for servers and for ext/ldap supporting this function. Set to \nTRUE\n to always use an emulated rename operation.\n\n\n\n\n\n\ncopyToSubtree(string|Dn $from, string|Dn $to, bool $recursively) : void\n\n\nCopies the entry identified by \n$from\n to a location below \n$to\n keeping its RDN unchanged. \n$recursively\n specifies if the operation will be carried out recursively (\nfalse\n by default) so that the entry \n$from\n and all its descendants will be copied. Copying will fail if \n$recursively\n is \nfalse\n and the entry \n$from\n is not a leaf entry.\n\n\n\n\n\n\ncopy(string|Dn $from, string|Dn $to, bool $recursively) : void\n\n\nCopies the entry identified by \n$from\n to \n$to\n. \n$recursively\n specifies if the operation will be carried out recursively (\nfalse\n by default) so that the entry \n$from\n and all its descendants will be copied. Copying will fail if \n$recursively\n is \nfalse\n and the entry \n$from\n is not a leaf entry.\n\n\n\n\n\n\ngetNode(string|Dn $dn) : Node\n\n\nReturns the entry \n$dn\n wrapped in a \nZend\\Ldap\\Node\n.\n\n\n\n\n\n\ngetBaseNode() : Node\n\n\nReturns the entry for the base DN \n$baseDn\n wrapped in a \nZend\\Ldap\\Node\n.\n\n\n\n\n\n\ngetRootDse() : Node\\RootDse\n\n\nReturns the RootDSE for the current server.\n\n\n\n\n\n\ngetSchema() : Node\\Schema\n\n\nReturns the LDAP schema for the current server.\n\n\n\n\n\n\n\n\nsearch()\n\n\nThe \nsearch()\n signature is as follows:\n\n\nsearch(\n    string|Filter\\AbstractFilter $filter,\n    string|Dn $basedn,\n    int $scope,\n    array $attributes,\n    string $sort,\n    string $collectionClass,\n    int $sizelimit,\n    int $timelimit\n) : Collection\n\n\n\nwhere:\n\n\n\n\n$filter\n: The filter string to be used in the search, e.g. \n(objectClass=posixAccount)\n.\n\n\n$basedn\n: The search base for the search. If omitted or \nnull\n, the \nbaseDn\n\n  from the connection and binding parameters is used.\n\n\n$scope\n: The search scope:\n\n\nLdap::SEARCH_SCOPE_SUB\n searches the complete subtree including the\n  \n$baseDn\n node. This is the default value.\n\n\nLdap::SEARCH_SCOPE_ONE\n restricts search to one level below \n$baseDn\n.\n\n\nLdap::SEARCH_SCOPE_BASE\n restricts search to the \n$baseDn\n itself; this\n  can be used to efficiently retrieve a single entry by its DN.\n\n\n\n\n\n\n$attributes\n: Specifies the attributes contained in the returned entries. To\n  include all possible attributes (ACL restrictions can disallow certain\n  attribute to be retrieved by a given user), pass either an empty array (\n[]\n)\n  or an array containing a wildcard (\n['*']\n) to the method. On some LDAP\n  servers, you can retrieve special internal attributes by passing \n['*', '+']\n\n  to the method.\n\n\n$sort\n: If given, the result collection will be sorted according to the\n  attribute \n$sort\n. Results can only be sorted after one single attribute as\n  this parameter uses the ext/ldap function \nldap_sort()\n.\n\n\n$collectionClass\n: If given, the result will be wrapped in an object of type\n  \n$collectionClass\n. By default, an object of type \nZend\\Ldap\\Collection\n will\n  be returned. The custom class must extend \nZend\\Ldap\\Collection\n, and will be\n  passed a \nZend\\Ldap\\Collection\\Iterator\\Default\n on instantiation.\n\n\n$sizelimit\n: Enables you to limit the count of entries fetched. Setting this\n  to \n0\n means no limit.\n\n\n$timelimit\n: Sets the maximum number of seconds to spend on the search.\n  Setting this to \n0\n means no limit.\n\n\n\n\nsearchEntries()\n\n\nsearchEntries(\n    string|Dn $basedn,\n    int $scope,\n    array $attributes,\n    string $sort,\n    bool $reverseSort,\n    int $sizelimit,\n    int $timelimit\n) : array\n\n\n\nArguments are essentially the same as for \nsearch()\n, with two\ndifferences:\n\n\n\n\n$reverseSort\n: a boolean indicating whether or not the results should be\n  returned in reverse sort order.\n\n\n$collectionClass\n is not present in this signature.\n\n\n\n\nUnlike \nsearch()\n, this method always returns an array of results.\n\n\nZend\\Ldap\\Collection\n\n\nZend\\Ldap\\Collection\n implements \nIterator\n to allow for item traversal using\n\nforeach()\n and \nCountable\n to be able to respond to \ncount()\n. With its\nprotected \ncreateEntry()\n method, it provides an extension point for developers\nneeding custom result objects.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__construct(Collection\\DefaultIterator $iterator) : void\n\n\nThe constructor must be provided with a \nZend\\Ldap\\Collection\\DefaultIterator\n, which does the real result iteration.\n\n\n\n\n\n\nclose() : bool\n\n\nCloses the internal iterator. This is also called in the destructor.\n\n\n\n\n\n\ntoArray() : array\n\n\nReturns all entries as an array.\n\n\n\n\n\n\ngetFirst() : array\n\n\nReturns the first entry in the collection or \nnull\n if the collection is empty.\n\n\n\n\n\n\n\n\nZend\\Ldap\\Attribute\n\n\nZend\\Ldap\\Attribute\n is a helper class providing only static methods to\nmanipulate arrays suitable to the structure used in \nZend\\Ldap\\Ldap\n data\nmodification methods, and to the data format required by the LDAP server. PHP\ndata types are converted using \nZend\\Ldap\\Converter\\Converter\n methods.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic setAttribute(array \n$data, string $attribName, mixed $value, bool $append) : void\n\n\nSets the attribute \n$attribName\n in \n$data\n to the value \n$value\n. If \n$append\n is \ntrue\n (\nfalse\n by default) \n$value\n will be appended to the attribute. \n$value\n can be a scalar value or an array of scalar values. Conversion will take place.\n\n\n\n\n\n\nstatic getAttribute(array $data, string $attribName, int|null $index) : array|mixed\n\n\nReturns the attribute \n$attribName\n from \n$data\n. If \n$index\n is \nnull\n (default), an array will be returned containing all the values for the given attribute. An empty array will be returned if the attribute does not exist in the given array. If an integer index is specified the corresponding value at the given index will be returned. If the index is out of bounds, \nnull\n will be returned. Conversion will take place.\n\n\n\n\n\n\nstatic attributeHasValue(array \n$data, string $attribName, mixed|array $value) : bool\n\n\nChecks if the attribute \n$attribName\n in \n$data\n has the value(s) given in \n$value\n. The method returns \ntrue\n only if all values in \n$value\n are present in the attribute. Comparison is done strictly (respecting the data type).\n\n\n\n\n\n\nstatic removeDuplicatesFromAttribute(array \n$data, string $attribName) : void\n\n\nRemoves all duplicates from the attribute \n$attribName\n in \n$data\n.\n\n\n\n\n\n\nstatic removeFromAttribute(array \n$data, string $attribName, mixed|array $value) : void\n\n\nRemoves the value(s) given in \n$value\n from the attribute \n$attribName\n in \n$data\n.\n\n\n\n\n\n\nstatic setPassword(/* ... */) : void\n\n\nSee \nsetPassword\n below for details.\n\n\n\n\n\n\nstatic createPassword(string $password, string $hashType) : string\n\n\nCreates an LDAP password. The password hash can be specified with \n$hashType\n. The default value here is \nAttribute::PASSWORD_HASH_MD5\n with \nAttribute::PASSWORD_HASH_SHA\n as the other possibility.\n\n\n\n\n\n\nstatic setDateTimeAttribute(/\n ... \n/) : void\n\n\nSee \nsetDateTimeAttribute()\n below for details.\n\n\n\n\n\n\nstatic getDateTimeAttribute(/\n ... \n/) : array\n\n\nint\n\n\n\n\n\n\n\n\nsetPassword()\n\n\nThe full signature of \nsetPassword()\n is as follows:\n\n\nstatic setPassword(\n    array \n$data,\n    string $password,\n    string $hashType,\n    string $attribName\n) : void\n\n\n\nSets an LDAP password for the attribute \n$attribName\n in \n$data\n. \n$attribName\n\ndefaults to \nuserPassword\n which is the standard password attribute. The\npassword hash can be specified with \n$hashType\n. The default value here is\n\nAttribute::PASSWORD_HASH_MD5\n with \nAttribute::PASSWORD_HASH_SHA\n as the other\npossibility.\n\n\nsetDateTimeAttribute()\n\n\nThe full signature of \nsetDateTimeAttribute()\n is as follows:\n\n\nstatic setDateTimeAttribute(\n    array \n$data,\n    string $attribName,\n    int|array $value,\n    boolean $utc,\n    boolean $append\n) : void\n\n\n\nSets the attribute \n$attribName\n in \n$data\n to the date/time value \n$value\n. if\n\n$append\n is \ntrue\n (\nfalse\n by default) \n$value\n will be appended to the\nattribute. \n$value\n can be an integer value or an array of integers.\nDate-time-conversion according to \nConverter\\Converter::toLdapDateTime()\n will\ntake place.\n\n\ngetDateTimeAttribute()\n\n\nThe full signature of \ngetDateTimeAttribute()\n is as follows:\n\n\nstatic getDateTimeAttribute(\n    array $data,\n    string $attribName,\n    int|null $index\n) : array|int\n\n\n\nReturns the date/time attribute \n$attribName\n from \n$data\n. If \n$index\n is\n\nnull\n (default), an array will be returned containing all the date/time values\nfor the given attribute. An empty array will be returned if the attribute does\nnot exist in the given array. If an integer index is specified the corresponding\ndate/time value at the given index will be returned. If the index is out of\nbounds, \nnull\n will be returned. Date-time-conversion according to\n\nConverter\\Converter::fromLdapDateTime()\n will take place.\n\n\nZend\\Ldap\\Converter\\Converter\n\n\nZend\\Ldap\\Converter\\Converter\n is a helper class providing only static methods\nto manipulate arrays suitable to the data format required by the LDAP server.\nPHP data types are converted the following way:\n\n\n\n\nstring\n: No conversion will be done.\n\n\ninteger and float\n: The value will be converted to a string.\n\n\nboolean\n: \ntrue\n will be converted to \n'TRUE'\n and \nfalse\n to \n'FALSE'\n.\n\n\nobject and array\n: The value will be converted to a string by using \nserialize()\n.\n\n\nDate/Time\n: The value will be converted to a string with the following\n  \ndate()\n format \nYmdHisO\n, UTC timezone (\n+0000\n) will be replaced with a \nZ\n.\n  For example \n01-30-2011 01:17:32 PM GMT-6\n will be \n20113001131732-0600\n and\n  \n30-01-2012 15:17:32 UTC\n will be \n20120130151732Z\n.\n\n\nresource\n: If a stream resource is given, the data will be fetched by calling \nstream_get_contents()\n.\n\n\nOthers: All other data types (namely non-stream resources) will be omitted.\n\n\n\n\nOn reading values, the following conversion will take place:\n\n\n\n\n'TRUE'\n: Converted to \ntrue\n.\n\n\n'FALSE'\n: Converted to \nfalse\n.\n\n\nOthers: All other strings won't be automatically converted and are passed as they are.\n\n\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic ascToHex32(string $string) : string\n\n\nConvert all Ascii characters with decimal value less than 32 to hexadecimal value.\n\n\n\n\n\n\nstatic hex32ToAsc(string $string) : string\n\n\nConvert all hexadecimal characters to Ascii values.\n\n\n\n\n\n\nstatic toLdap(mixed $value, int $type) : string|null\n\n\nConverts a PHP data type into its LDAP representation. \n$type\n argument is used to set the conversion method. The default, \nConverter::STANDARD\n, allows the function to try to guess the conversion method to use. Others possibilities are \nConverter::BOOLEAN\n and \nConverter::GENERALIZED_TIME\n. See the introduction for details.\n\n\n\n\n\n\nstatic fromLdap(string $value, int $type, bool $dateTimeAsUtc) : mixed\n\n\nConverts an LDAP value into its PHP data type. See introduction and \ntoLdap()\n and \ntoLdapDateTime()\n for details.\n\n\n\n\n\n\nstatic toLdapDateTime(int|string|DateTime $date, bool $asUtc) : string|null\n\n\nConverts a timestamp, a \nDateTime\n instance, or a string that is parseable by \nstrtotime()\n into its LDAP date/time representation. If \n$asUtc\n is \ntrue\n (\nfalse\n by default), the resulting LDAP date/time string will be in UTC; otherwise a local date/time string will be returned.\n\n\n\n\n\n\nstatic fromLdapDateTime(string $date, boolean $asUtc) : DateTime\n\n\nConverts LDAP date/time representation into a PHP \nDateTime\n object.\n\n\n\n\n\n\nstatic toLdapBoolean(bool|int|string $value) : string\n\n\nConverts a PHP data type into its LDAP boolean representation. By default, always return \nfalse\n except if the value is \ntrue\n, \n'true'\n, or \n1\n.\n\n\n\n\n\n\nstatic fromLdapBoolean(string $value) : bool\n\n\nConverts LDAP boolean representation into a PHP boolean data type.\n\n\n\n\n\n\nstatic toLdapSerialize(mixed $value) : string\n\n\nThe value will be converted to a string by using \nserialize()\n.\n\n\n\n\n\n\nstatic fromLdapUnserialize(string $value) : mixed\n\n\nThe value will be converted from a string by using \nunserialize()\n.\n\n\n\n\n\n\n\n\nZend\\Ldap\\Dn\n\n\nZend\\Ldap\\Dn\n provides an object-oriented interface to manipulating LDAP\ndistinguished names (DN). The parameter \n$caseFold\n that is used in several\nmethods determines the way DN attributes are handled regarding their case.\nAllowed values for this parameter are:\n\n\n\n\nDn::ATTR_CASEFOLD_NONE\n: No case-folding will be done.\n\n\nDn::ATTR_CASEFOLD_UPPER\n: All attributes will be converted to upper-case.\n\n\nDn::ATTR_CASEFOLD_LOWER\n: All attributes will be converted to lower-case.\n\n\n\n\nThe default case-folding is \nDn::ATTR_CASEFOLD_NONE\n; set an alternative with\n\nDn::setDefaultCaseFold()\n. Each instance of \nZend\\Ldap\\Dn\n can have its own\ncase-folding setting. If the \n$caseFold\n parameter is omitted in method-calls it\ndefaults to the instance's case-folding setting.\n\n\nThe class implements \nArrayAccess\n to allow indexer-access to the different\nparts of the DN. The \nArrayAccess\n methods proxy to \nDn::get($offset, 1, null)\n\nfor \noffsetGet(int $offset)\n, to \nDn::set($offset, $value)\n for \noffsetSet()\n,\nand to \nDn::remove($offset, 1)\n for \noffsetUnset()\n. \noffsetExists()\n simply\nchecks if the index is within the bounds.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic factory(string|array $dn, string|null $caseFold) : Dn\n\n\nCreates an instance from an array or a string. The array must conform to the array structure detailed under \nDn::implodeDn()\n.\n\n\n\n\n\n\nstatic fromString(string $dn, string|null $caseFold) : Dn\n\n\nCreates an instance from a string.\n\n\n\n\n\n\nstatic fromArray(array $dn, string|null $caseFold) : Dn\n\n\nCreates an instance from an array. The array must conform to the array structure detailed under \nDn::implodeDn()\n.\n\n\n\n\n\n\ngetRdn(string|null $caseFold) : array\n\n\nGets the RDN of the current DN. The return value is an array with the RDN attribute names its keys and the RDN attribute values.\n\n\n\n\n\n\ngetRdnString(string|null $caseFold) : string\n\n\nGets the RDN of the current DN. The return value is a string.\n\n\n\n\n\n\ngetParentDn(integer $levelUp) : Dn\n\n\nGets the DN of the current DN\u2019s ancestor \n$levelUp\n levels up the tree. \n$levelUp\n defaults to \n1\n.\n\n\n\n\n\n\nget(int $index, int $length, string|null $caseFold) : array\n\n\nReturns a slice of the current DN determined by \n$index\n and \n$length\n. \n$index\n starts with \n0\n on the DN part from the left.\n\n\n\n\n\n\nset(int $index, array $value) : void\n\n\nReplaces a DN part in the current DN. This operation manipulates the current instance.\n\n\n\n\n\n\nremove(int $index, int $length) : void\n\n\nRemoves a DN part from the current DN. This operation manipulates the current instance. $length defaults to 1\n\n\n\n\n\n\nappend(array $value) : void\n\n\nAppends a DN part to the current DN. This operation manipulates the current instance.\n\n\n\n\n\n\nprepend(array $value) : void\n\n\nPrepends a DN part to the current DN. This operation manipulates the current instance.\n\n\n\n\n\n\ninsert(int $index, array $value) : void\n\n\nInserts a DN part after the index \n$index\n to the current DN. This operation manipulates the current instance.\n\n\n\n\n\n\nsetCaseFold(string|null $caseFold) : void\n\n\nSets the case-folding option to the current DN instance. If \n$caseFold\n is \nnull\n, the default case-folding setting is used for the current instance.\n\n\n\n\n\n\ntoString(string|null $caseFold) : string\n\n\nReturns DN as a string.\n\n\n\n\n\n\ntoArray(string|null $caseFold) : array\n\n\nReturns DN as an array.\n\n\n\n\n\n\n__toString() : string\n\n\nReturns DN as a string; proxies to \nDn::toString(null)\n.\n\n\n\n\n\n\nstatic setDefaultCaseFold(string $caseFold) : void\n\n\nSets the default case-folding option used by all instances on creation by default. Already existing instances are not affected by this setting.\n\n\n\n\n\n\nescapeValue(string|array $values) : array\n\n\nEscapes a DN value according to RFC 2253.\n\n\n\n\n\n\nunescapeValue(string|array $values) : array\n\n\nUndoes the conversion done by \nDn::escapeValue()\n.\n\n\n\n\n\n\nexplodeDn(string $dn, array \n$keys, array \n$vals, string|null $caseFold) : array\n\n\nExplodes the DN \n$dn\n into an array containing all parts of the given DN. \n$keys\n optionally receive DN keys (e.g. CN, OU, DC, ...). \n$vals\n optionally receive DN values. The resulting array will be of type \n[ ['cn' =\n 'name1', 'uid' =\n 'user'], ['cn' =\n 'name2'), ['dc' =\n 'example'], ['dc' =\n 'org'] ]\n for a DN of \ncn=name1+uid=user,cn=name2,dc=example,dc=org\n.\n\n\n\n\n\n\ncheckDn(string $dn, array \n$keys, array \n$vals, string|null $caseFold) : bool\n\n\nChecks if a given DN \n$dn\n is malformed. If \n$keys\n or \n$keys\n and \n$vals\n are given, these arrays will be filled with the appropriate DN keys and values.\n\n\n\n\n\n\nimplodeRdn(array $part, string|null $caseFold) : string\n\n\nReturns a DN part in the form \n$attribute=$value\n\n\n\n\n\n\nimplodeDn(array $dnArray, string|null $caseFold, string $separator) : string\n\n\nImplodes an array in the form delivered by \nDn::explodeDn()\n to a DN string.  \n$separator\n defaults to \n,\n but some LDAP servers also understand \n;\n.  \n$dnArray\n must of type \n[ ['cn' =\n 'name1', 'uid' =\n 'user'], ['cn' =\n 'name2'], ['dc' =\n 'example'], ['dc' =\n 'org'] ]\n\n\n\n\n\n\nisChildOf(string|Dn $childDn, string|Dn $parentDn) : bool\n\n\nChecks if given \n$childDn\n is beneath \n$parentDn\n subtree.\n\n\n\n\n\n\n\n\nZend\\Ldap\\Filter\n\n\nZend\\Ldap\\Node\n\n\nZend\\Ldap\\Node\n includes the magic property accessors \n__set()\n, \n__get()\n,\n\n__unset()\n, and \n__isset()\n for accessing the attributes by name. They proxy to\n\nNode::setAttribute()\n, \nNode::getAttribute()\n, \nNode::deleteAttribute()\n, and\n\nNode::existsAttribute()\n respectively. Furthermore the class implements\n\nArrayAccess\n for array-style access to the attributes. \nZend\\Ldap\\Node\n also\nimplements \nIterator\n and \nRecursiveIterator\n to allow for recursive\ntree-traversal.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstatic equals(string $attr, string $value) : Filter\n\n\nCreates an \"equals\" filter: \n(attr=value)\n.\n\n\n\n\n\n\nbegins(string $attr, string $value) : Filter\n\n\nCreates a \"begins with\" filter: \n(attr=value*)\n.\n\n\n\n\n\n\nends(string $attr, string $value) : Filter\n\n\nCreates an \"ends with\" filter: \n(attr=*value)\n.\n\n\n\n\n\n\ncontains(string $attr, string $value) : Filter\n\n\nCreates a \"contains\" filter: \n(attr=*value*)\n.\n\n\n\n\n\n\ngreater(string $attr, string $value) : Filter\n\n\nCreates a \"greater than\" filter: \n(attr\nvalue)\n.\n\n\n\n\n\n\ngreaterOrEqual(string $attr, string $value) : Filter\n\n\nCreates a \"greater than or equal\" filter: \n(attr\n=value)\n.\n\n\n\n\n\n\nless(string $attr, string $value) : Filter\n\n\nCreates a \"less than\" filter: \n(attr\nvalue)\n.\n\n\n\n\n\n\nlessOrEqual(string $attr, string $value) : Filter\n\n\nCreates a \"less than or equal\" filter: \n(attr\n=value)\n.\n\n\n\n\n\n\napprox(string $attr, string $value) : Filter\n\n\nCreates an \"approx\" filter: \n(attr~=value)\n.\n\n\n\n\n\n\nany(string $attr) : Filter\n\n\nCreates an \"any\" filter: \n(attr=*)\n.\n\n\n\n\n\n\nstring(string $filter) : Filter\n\n\nCreates a simple custom string filter. The user is responsible for all value-escaping as the filter is used as is.\n\n\n\n\n\n\nmask(string $mask, string $value, ...) : Filter\n\n\nCreates a filter from a string mask. All \n$value\n parameters will be escaped and substituted into \n$mask\n by using \nsprintf()\n.\n\n\n\n\n\n\nandFilterFilter\\AbstractFilter $filter, ...) : Filter\n\n\nCreates an \"and\" filter from all arguments given.\n\n\n\n\n\n\norFilter(Filter\\AbstractFilter $filter, ...) : Filter\n\n\nCreates an \"or\" filter from all arguments given.\n\n\n\n\n\n\n__construct(/* ... */) : void\n\n\nCreate an arbitrary filter according to the parameters supplied; see the \nNode constructor\n below for the full signature.\n\n\n\n\n\n\ntoString() : string\n\n\nReturns a string representation of the filter.\n\n\n\n\n\n\n__toString() : string\n\n\nReturns a string representation of the filter. Proxies to \nFilter::toString()\n.\n\n\n\n\n\n\nnegate() : Filter\\NotFilter\n\n\nCreates and returns a new filter that is a negation of the current filter.\n\n\n\n\n\n\naddAnd(Filter\\AbstractFilter $filter, ...) : Filter\\AndFilter\n\n\nCreates an \"and\" filter from the current filter and all filters passed in as the arguments.\n\n\n\n\n\n\naddOr(Filter\\AbstractFilter $filter, ...) : Filter\\OrFilter\n\n\nCreates an \"or\" filter from the current filter and all filters passed in as the arguments.\n\n\n\n\n\n\nescapeValue(string|array $values) : string|array\n\n\nEscapes the given \n$values\n according to RFC 2254 so that they can be safely used in LDAP filters. If a single string is given, a string is returned, otherwise an array is returned.  Any control characters with an ASCII code \n 32\n as well as characters with special meaning in LDAP filters (\n*\n, \n(\n, \n)\n, and \n\\\\\n (the backslash)) are converted into the representation of a backslash followed by two hex digits representing the hexadecimal value of the character.\n\n\n\n\n\n\nunescapeValue(string|array $values) : string|array\n\n\nUndoes the conversion done by \nFilter::escapeValue()\n. Converts any sequences of a backslash followed by two hex digits into the corresponding character.\n\n\n\n\n\n\n\n\nNode constructor\n\n\nThe full signature of the \nZend\\Ldap\\Node\n constructor is:\n\n\n__construct(\n    string $attr,\n    string $value,\n    string $filtertype,\n    string|null $prepend,\n    string|null $append\n) : void\n\n\n\nThe resulting filter will be a concatenation of \n$attr\n, \n$filtertype\n,\n\n$prepend\n, \n$value\n, and \n$append\n. Normally this constructor is not needed, as\nall filters can be created by using the appropriate factory methods.\n\n\nZend\\Ldap\\Node\\RootDse\n\n\nThe following methods are available on all vendor-specific subclasses.\n\n\nZend\\Ldap\\Node\\RootDse\n includes the magic property accessors \n__get()\n and\n\n__isset()\n to access the attributes by their name. They proxy to\n\nNode\\RootDse::getAttribute()\n and \nNode\\RootDse::existsAttribute()\n\nrespectively. \n__set()\n and \n__unset()\n are also implemented but they throw a\n\nBadMethodCallException\n, as modifications are not allowed on RootDSE nodes.\nFurthermore the class implements \nArrayAccess\n for array-style access to the\nattributes.  \noffsetSet()\n and \noffsetUnset()\n also throw a\n\nBadMethodCallException\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetDn() : Dn\n\n\nGets the DN of the current node as a \nZend\\Ldap\\Dn\n instance.\n\n\n\n\n\n\ngetDnString(string $caseFold) : string\n\n\nGets the DN of the current node as a string.\n\n\n\n\n\n\ngetDnArray(string $caseFold) : array\n\n\nGets the DN of the current node as an array.\n\n\n\n\n\n\ngetRdnString(string $caseFold) : string\n\n\nGets the RDN of the current node as a string.\n\n\n\n\n\n\ngetRdnArray(string $caseFold) : array\n\n\nGets the RDN of the current node as an array.\n\n\n\n\n\n\ngetObjectClass() : array\n\n\nReturns the \nobjectClass\n of the node.\n\n\n\n\n\n\ntoString() : string\n\n\nReturns the DN of the current node; proxies to \nZend\\Ldap\\Dn::getDnString()\n.\n\n\n\n\n\n\n__toString() : string\n\n\nCasts to string representation; proxies to \nZend\\Ldap\\Dn::toString()\n.\n\n\n\n\n\n\ntoArray(bool $includeSystemAttributes) : array\n\n\nReturns an array representation of the current node. If \n$includeSystemAttributes\n is \nfalse\n (defaults to \ntrue\n), the system specific attributes are stripped from the array. Unlike \ngetAttributes()\n, the resulting array contains the DN with key \u2018dn\u2019.\n\n\n\n\n\n\ntoJson(bool $includeSystemAttributes) : string\n\n\nReturns a JSON representation of the current node using \ntoArray()\n.\n\n\n\n\n\n\ngetData(bool $includeSystemAttributes) : array\n\n\nReturns the node's attributes. The array contains all attributes in its internal format (no conversion).\n\n\n\n\n\n\nexistsAttribute(string $name, bool $emptyExists) : bool\n\n\nChecks whether a given attribute exists. If \n$emptyExists\n is \nfalse\n, empty attributes (containing only \n[]\n) are treated as non-existent, returning \nfalse\n. If \n$emptyExists\n is \ntrue\n, empty attributes are treated as existent, returning \ntrue\n. In this case, the method returns \nfalse\n only if the attribute name is missing in the key-collection.\n\n\n\n\n\n\nattributeHasValue(string $name, mixed|array $value) : bool\n\n\nChecks if the given value(s) exist in the attribute. The method returns \ntrue\n only if all values in \n$value\n are present in the attribute. Comparison is done strictly (respecting the data type).\n\n\n\n\n\n\ncount() : int\n\n\nReturns the number of attributes in the node. Implements \nCountable\n.\n\n\n\n\n\n\ngetAttribute(string $name, int|null $index) : mixed\n\n\nGets an LDAP attribute. Data conversion is applied using \nAttribute::getAttribute()\n.\n\n\n\n\n\n\ngetAttributes(bool $includeSystemAttributes) : array\n\n\nGets all attributes of node. If \n$includeSystemAttributes\n is \nfalse\n (defaults to \ntrue\n), the system specific attributes are stripped from the array.\n\n\n\n\n\n\ngetDateTimeAttribute(string $name, int|null $index) : array|int\n\n\nGets an LDAP date/time attribute. Data conversion is applied using \nAttribute::getDateTimeAttribute()\n.\n\n\n\n\n\n\nreload(Ldap $ldap) : void\n\n\nReloads the current node's attributes from the given LDAP server.\n\n\n\n\n\n\nstatic create(Ldap $ldap) : RootDse\n\n\nFactory method to create the RootDSE.\n\n\n\n\n\n\ngetNamingContexts() : array\n\n\nGets the \nnamingContexts\n.\n\n\n\n\n\n\ngetSubschemaSubentry() : string|null\n\n\nGets the \nsubschemaSubentry\n.\n\n\n\n\n\n\nsupportsVersion(string|int|array $versions) : bool\n\n\nDetermines if the LDAP version is supported.\n\n\n\n\n\n\nsupportsSaslMechanism(string|array $mechlist) : bool\n\n\nDetermines if the SASL mechanism is supported.\n\n\n\n\n\n\ngetServerType() : int\n\n\nGets the server type. Returns \nRootDse::SERVER_TYPE_GENERIC\n for unknown LDAP servers, \nRootDse::SERVER_TYPE_OPENLDAP\n for OpenLDAP servers, \nRootDse::SERVER_TYPE_ACTIVEDIRECTORY\n for Microsoft ActiveDirectory servers, and \nRootDse::SERVER_TYPE_EDIRECTORY\n for Novell eDirectory servers.\n\n\n\n\n\n\ngetSchemaDn() : Dn\n\n\nReturns the schema DN.\n\n\n\n\n\n\n\n\nOpenLDAP\n\n\nAdditionally the common methods above apply to instances of \nZend\\Ldap\\Node\\RootDse\\OpenLdap\n.\n\n\nRefer to \nLDAP Operational Attributes and Objects\n\nspecification for information on the attributes of OpenLDAP RootDSE.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetServerType() : int\n\n\nGets the server type. Returns \nZend\\Ldap\\Node\\RootDse::SERVER_TYPE_OPENLDAP\n\n\n\n\n\n\ngetConfigContext() : string|null\n\n\nGets the \nconfigContext\n.\n\n\n\n\n\n\ngetMonitorContext() : string|null\n\n\nGets the \nmonitorContext\n.\n\n\n\n\n\n\nsupportsControl(string|array $oids) : bool\n\n\nDetermines if the control is supported.\n\n\n\n\n\n\nsupportsExtension(string|array $oids) : bool\n\n\nDetermines if the extension is supported.\n\n\n\n\n\n\nsupportsFeature(string|array $oids) : bool\n\n\nDetermines if the feature is supported.\n\n\n\n\n\n\n\n\nActiveDirectory\n\n\nAdditionally the common methods above apply to instances of\n\nZend\\Ldap\\Node\\RootDse\\ActiveDirectory\n.\n\n\nRefer to the \nRootDSE\n\nspecification for information on the attributes of Microsoft ActiveDirectory\nRootDSE.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetServerType() : int\n\n\nGets the server type. Returns \nZend\\Ldap\\Node\\RootDse::SERVER_TYPE_ACTIVEDIRECTORY\n\n\n\n\n\n\ngetConfigurationNamingContext() : string|null\n\n\nGets the \nconfigurationNamingContext\n.\n\n\n\n\n\n\ngetCurrentTime() : string|null\n\n\nGets the \ncurrentTime\n.\n\n\n\n\n\n\ngetDefaultNamingContext() : string|null\n\n\nGets the \ndefaultNamingContext\n.\n\n\n\n\n\n\ngetDnsHostName() : string|null\n\n\nGets the \ndnsHostName\n.\n\n\n\n\n\n\ngetDomainControllerFunctionality() : string|null\n\n\nGets the \ndomainControllerFunctionality\n.\n\n\n\n\n\n\ngetDomainFunctionality() : string|null\n\n\nGets the \ndomainFunctionality\n.\n\n\n\n\n\n\ngetDsServiceName() : string|null\n\n\nGets the \ndsServiceName\n.\n\n\n\n\n\n\ngetForestFunctionality() : string|null\n\n\nGets the \nforestFunctionality\n.\n\n\n\n\n\n\ngetHighestCommittedUSN() : string|null\n\n\nGets the \nhighestCommittedUSN\n.\n\n\n\n\n\n\ngetIsGlobalCatalogReady() : string|null\n\n\nGets the \nisGlobalCatalogReady\n.\n\n\n\n\n\n\ngetIsSynchronized() : string|null\n\n\nGets the \nisSynchronized\n.\n\n\n\n\n\n\ngetLdapServiceName() : string|null\n\n\nGets the \nldapServiceName\n.\n\n\n\n\n\n\ngetRootDomainNamingContext() : string|null\n\n\nGets the \nrootDomainNamingContext\n.\n\n\n\n\n\n\ngetSchemaNamingContext() : string|null\n\n\nGets the \nschemaNamingContext\n.\n\n\n\n\n\n\ngetServerName() : string|null\n\n\nGets the \nserverName\n.\n\n\n\n\n\n\nsupportsCapability(string|array $oids) : bool\n\n\nDetermines if the capability is supported.\n\n\n\n\n\n\nsupportsControl(string|array $oids) : bool\n\n\nDetermines if the control is supported.\n\n\n\n\n\n\nsupportsPolicy(string|array $policies) : bool\n\n\nDetermines if the version is supported.\n\n\n\n\n\n\n\n\neDirectory\n\n\nAdditionally the common methods above apply to instances of\n\nZend\\Ldap\\Node\\RootDse\\eDirectory\n.\n\n\nRefer to \nGetting Information about the LDAP Server\n\nfor information on the attributes of Novell eDirectory RootDSE.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetServerType() : int\n\n\nGets the server type. Returns \nZend\\Ldap\\Node\\RootDse::SERVER_TYPE_EDIRECTORY\n\n\n\n\n\n\nsupportsExtension(string|array $oids) : bool\n\n\nDetermines if the extension is supported.\n\n\n\n\n\n\ngetVendorName() : string|null\n\n\nGets the \nvendorName\n.\n\n\n\n\n\n\ngetVendorVersion() : string|null\n\n\nGets the \nvendorVersion\n.\n\n\n\n\n\n\ngetDsaName() : string|null\n\n\nGets the \ndsaName\n.\n\n\n\n\n\n\ngetStatisticsErrors() : string|null\n\n\nGets the server statistics \nerrors\n.\n\n\n\n\n\n\ngetStatisticsSecurityErrors() : string|null\n\n\nGets the server statistics \nsecurityErrors\n.\n\n\n\n\n\n\ngetStatisticsChainings() : string|null\n\n\nGets the server statistics \nchainings\n.\n\n\n\n\n\n\ngetStatisticsReferralsReturned() : string|null\n\n\nGets the server statistics \nreferralsReturned\n.\n\n\n\n\n\n\ngetStatisticsExtendedOps() : string|null\n\n\nGets the server statistics \nextendedOps\n.\n\n\n\n\n\n\ngetStatisticsAbandonOps() : string|null\n\n\nGets the server statistics \nabandonOps\n.\n\n\n\n\n\n\ngetStatisticsWholeSubtreeSearchOps() : string|null\n\n\nGets the server statistics \nwholeSubtreeSearchOps\n.\n\n\n\n\n\n\n\n\nZend\\Ldap\\Node\\Schema\n\n\nThe following methods are available on all vendor-specific subclasses.\n\n\nZend\\Ldap\\Node\\Schema\n includes the magic property accessors \n__get()\n and \n__isset()\n to access\nthe attributes by their name. They proxy to \nSchema::getAttribute()\n and\n\nSchema::existsAttribute()\n respectively. \n__set()\n and \n__unset()\n are also\nimplemented, but they throw a \nBadMethodCallException\n, as modifications are not allowed on RootDSE\nnodes. Furthermore the class implements \nArrayAccess\n for array-style access to the attributes.\n\noffsetSet()\n and \noffsetUnset()\n also throw a \nBadMethodCallException\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetDn() : Dn\n\n\nGets the DN of the current node as a \nZend\\Ldap\\Dn\n instance.\n\n\n\n\n\n\ngetDnString(string $caseFold) : string\n\n\nGets the DN of the current node as a string.\n\n\n\n\n\n\ngetDnArray(string $caseFold) : array\n\n\nGets the DN of the current node as an array.\n\n\n\n\n\n\ngetRdnString(string $caseFold) : string\n\n\nGets the RDN of the current node as a string.\n\n\n\n\n\n\ngetRdnArray(string $caseFold) : array\n\n\nGets the RDN of the current node as an array.\n\n\n\n\n\n\ngetObjectClass() : array\n\n\nReturns the \nobjectClass\n of the node.\n\n\n\n\n\n\ntoString() : string\n\n\nReturns the DN of the current node; proxies to \nZend\\Ldap\\Dn::getDnString()\n.\n\n\n\n\n\n\n__toString() : string\n\n\nCasts to string representation; proxies to \nZend\\Ldap\\Dn::toString()\n.\n\n\n\n\n\n\ntoArray(bool $includeSystemAttributes) : array\n\n\nReturns an array representation of the current node. If \n$includeSystemAttributes\n is \nfalse\n (defaults to \ntrue\n), the system specific attributes are stripped from the array. Unlike \nNode\\Schema::getAttributes()\n, the resulting array contains the DN with key \ndn\n.\n\n\n\n\n\n\ntoJson(bool $includeSystemAttributes) : string\n\n\nReturns a JSON representation of the current node using \nNode\\Schema::toArray()\n.\n\n\n\n\n\n\ngetData(bool $includeSystemAttributes) : array\n\n\nReturns the node\u2019s attributes. The array contains all attributes in its internal format (no conversion).\n\n\n\n\n\n\nexistsAttribute(string $name, bool $emptyExists) : bool\n\n\nChecks whether a given attribute exists. If \n$emptyExists\n is \nfalse\n, empty attributes (containing only \n[]\n) are treated as non-existent, returning \nfalse\n. If \n$emptyExists\n is \ntrue\n, empty attributes are treated as existent, returning \ntrue\n. In this case, the method returns \nfalse\n only if the attribute name is missing in the key-collection.\n\n\n\n\n\n\nattributeHasValue(string $name, mixed|array $value) : bool\n\n\nChecks if the given value(s) exist in the attribute. The method returns \ntrue\n only if all values in $value are present in the attribute. Comparison is done strictly (respecting the data type).\n\n\n\n\n\n\ncount() : int\n\n\nReturns the number of attributes in the node. Implements \nCountable\n.\n\n\n\n\n\n\ngetAttribute(string $name, int|null $index) : mixed\n\n\nGets an LDAP attribute.  Data conversion is applied using \nAttribute::getAttribute()\n.\n\n\n\n\n\n\ngetAttributes(bool $includeSystemAttributes) : array\n\n\nGets all attributes of node. If \n$includeSystemAttributes\n is \nfalse\n (defaults to \ntrue\n) the system specific attributes are stripped from the array.\n\n\n\n\n\n\ngetDateTimeAttribute(string $name, int|null $index) : array|int\n\n\nGets a LDAP date/time attribute. Data conversion is applied using \nAttribute::getDateTimeAttribute()\n.\n\n\n\n\n\n\nreload(Ldap $ldap) : void\n\n\nReloads the current node\u2019s attributes from the given LDAP server.\n\n\n\n\n\n\nstatic create(Ldap $ldap) : Node\\Schema\n\n\nFactory method to create the \nSchema\n node.\n\n\n\n\n\n\ngetAttributeTypes() : array\n\n\nGets the attribute types as an array.\n\n\n\n\n\n\ngetObjectClasses() : array\n\n\nGets the object classes as an array of \nZend\\Ldap\\Node\\Schema\\ObjectClass\\ObjectClassInterface\n instances.\n\n\n\n\n\n\n\n\nAttributeTypeInterface\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetName() : string\n\n\nGets the attribute name.\n\n\n\n\n\n\ngetOid() : string\n\n\nGets the attribute OID.\n\n\n\n\n\n\ngetSyntax() : string\n\n\nGets the attribute syntax.\n\n\n\n\n\n\ngetMaxLength() : int|null\n\n\nGets the attribute maximum length.\n\n\n\n\n\n\nisSingleValued() : bool\n\n\nReturns if the attribute is single-valued.\n\n\n\n\n\n\ngetDescription() : string\n\n\nGets the attribute description\n\n\n\n\n\n\n\n\nObjectClassInterface\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetName() : string\n\n\nReturns the objectClass name.\n\n\n\n\n\n\ngetOid() : string\n\n\nReturns the objectClass OID.\n\n\n\n\n\n\ngetMustContain() : array\n\n\nReturns the attributes that this objectClass must contain.\n\n\n\n\n\n\ngetMayContain() : array\n\n\nReturns the attributes that this objectClass may contain.\n\n\n\n\n\n\ngetDescription() : string\n\n\nReturns the attribute description\n\n\n\n\n\n\ngetType() : int\n\n\nReturns the \nobjectClass\n type. The method returns one of the following values: \nSchema::OBJECTCLASS_TYPE_UNKNOWN\n for unknown class types, \nSchema::OBJECTCLASS_TYPE_STRUCTURAL\n for structural classes, \nSchema::OBJECTCLASS_TYPE_ABSTRACT\n for abstract classes, \nSchema::OBJECTCLASS_TYPE_AUXILIARY\n for auxiliary classes.\n\n\n\n\n\n\ngetParentClasses() : array\n\n\nReturns the parent \nobjectClass\nes of this class. This includes structural, abstract and auxiliary \nobjectClass\nes.\n\n\n\n\n\n\n\n\nAbstractItem\n\n\nClasses representing attribute types and object classes extend\n\nZend\\Ldap\\Node\\Schema\\AbstractItem\n, which provides some core methods to access\narbitrary attributes on the underlying LDAP node.  \nAbstractItem\n includes the\nmagic property accessors \n__get()\n and \n__isset()\n to access the attributes by\ntheir name. Furthermore the class implements \nArrayAccess\n for\narray-style-access to the attributes. \noffsetSet()\n and \noffsetUnset()\n throw a\n\nBadMethodCallException\n, as modifications are not allowed on schema information\nnodes.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetData() : array\n\n\nGets all the underlying data from the schema information node.\n\n\n\n\n\n\ncount() : int\n\n\nReturns the number of attributes in this schema information node. Implements \nCountable\n.\n\n\n\n\n\n\n\n\nOpenLDAP\n\n\nAdditionally the common methods above apply to instances of\n\nZend\\Ldap\\Node\\Schema\\OpenLDAP\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetLdapSyntaxes() : array\n\n\nGets the LDAP syntaxes.\n\n\n\n\n\n\ngetMatchingRules() : array\n\n\nGets the matching rules.\n\n\n\n\n\n\ngetMatchingRuleUse() : array\n\n\nGets the matching rule use.\n\n\n\n\n\n\n\n\nZend\\Ldap\\Node\\Schema\\AttributeType\\OpenLDAP\n has the following API:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetParent() : Node\\Schema\\AttributeType\\OpenLdap|null\n\n\nReturns the parent attribute type in the inheritance tree if one exists.\n\n\n\n\n\n\n\n\nZend\\Ldap\\Node\\Schema\\ObjectClass\\OpenLDAP\n has the following API:\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetParents() : array\n\n\nReturns the parent object classes in the inheritance tree if one exists. The returned array is an array of \nZend\\Ldap\\Node\\Schema\\ObjectClass\\OpenLdap\n.\n\n\n\n\n\n\n\n\nActiveDirectory\n\n\n\n\nSchema browsing on ActiveDirectory servers\n\n\nDue to restrictions on Microsoft ActiveDirectory servers regarding the number\nof entries returned by generic search routines, and due to the structure of\nthe ActiveDirectory schema repository, schema browsing is currently \nnot\n\navailable for Microsoft ActiveDirectory servers.\n\n\n\n\nNone of \nZend\\Ldap\\Node\\Schema\\ActiveDirectory\n,\n\nZend\\Ldap\\Node\\Schema\\AttributeType\\ActiveDirectory\n, or\n\nZend\\Ldap\\Node\\Schema\\\\ObjectClass\\ActiveDirectory\n provide additional\nmethods.\n\n\nZend\\Ldap\\Ldif\\Encoder\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndecode(string $string) : array\n\n\nDecodes the string \n$string\n into an array of LDIF items.\n\n\n\n\n\n\nencode(scalar|array|Node $value, array $options) : string\n\n\nEncode \n$value\n into a LDIF representation.\n\n\n\n\n\n\n\n\nThe \n$options\n argument to \nencode()\n may contain the following keys:\n\n\n\n\nsort\n: Sort the given attributes with dn following \nobjectClass\n, and\n  following all other attributes sorted alphabetically. \ntrue\n by default.\n\n\nversion\n: The LDIF format version. \n1\n by default.\n\n\nwrap\n: The line-length. \n78\n by default to conform to the LDIF specification.", 
            "title": "API overview"
        }, 
        {
            "location": "/api/#api-overview", 
            "text": "", 
            "title": "API overview"
        }, 
        {
            "location": "/api/#configuration-options", 
            "text": "Zend\\Ldap\\Ldap  accepts an array of options either supplied to the constructor\nor through the  setOptions()  method. The permitted options are as follows:     Name  Description      host  The default hostname of the LDAP server if not supplied to  connect()  (also may be used when trying to canonicalize usernames in bind()).    port  Default port of the LDAP server if not supplied to  connect() .    useStartTls  Whether or not the LDAP client should use TLS (aka SSLv2) encrypted transport. A value of  true  is strongly favored in production environments to prevent passwords from be transmitted in clear text. The default value is  false , as servers frequently require that a certificate be installed separately after installation. The  useSsl  and  useStartTls  options are mutually exclusive. The  useStartTls  option should be favored over  useSsl , but not all servers support this newer mechanism.    useSsl  Whether or not the LDAP client should use SSL encrypted transport. The  useSsl  and  useStartTls  options are mutually exclusive.    username  The default credentials username. Some servers require that this be in DN form. This must be given in DN form if the LDAP server requires a DN to bind and binding should be possible with simple usernames.    password  The default credentials password (used only with username above).    bindRequiresDn  If  true , this instructs  Zend\\Ldap\\Ldap  to retrieve the DN for the account used to bind if the username is not already in DN form. The default value is  false .    baseDn  The default base DN used for searching (e.g., for accounts). This option is required for most account related operations and should indicate the DN under which accounts are located.    accountCanonicalForm  A small integer indicating the form to which account names should be canonicalized. See the  Account Name Canonicalization section .    accountDomainName  The FQDN domain for which the target LDAP server is an authority (e.g.,  example.com ).    accountDomainNameShort  The \u2018short\u2019 domain for which the target LDAP server is an authority. This is usually used to specify the NetBIOS domain name for Windows networks, but may also be used by non-AD servers.    accountFilterFormat  The LDAP search filter used to search for accounts. This string is a  sprintf()  style expression that must contain one  %s  to accommodate the username. The default value is  ( (objectClass=user)(sAMAccountName=%s))  unless  bindRequiresDn  is set to  true , in which case the default is  ( (objectClass=posixAccount)(uid=%s)) . Users of custom schemas may need to change this option.    allowEmptyPassword  Some LDAP servers can be configured to accept an empty string password as an anonymous bind. This behavior is almost always undesirable. For this reason, empty passwords are explicitly disallowed. Set this value to  true  to allow an empty string password to be submitted during the bind.    optReferrals  If set to  true , this option indicates to the LDAP client that referrals should be followed. The default value is  false .    tryUsernameSplit  If set to  false , this option indicates that the given username should not be split at the first  @  or  \\\\  character to separate the username from the domain during the binding-procedure. This allows the user to use usernames that contain an  @  or  \\\\  character that do not inherit some domain-information, e.g. using email-addresses for binding. The default value is  true .    networkTimeout  Number of seconds to wait for LDAP connection before fail. If not set, the default value is the system value.", 
            "title": "Configuration options"
        }, 
        {
            "location": "/api/#api-reference", 
            "text": "Class names are relative to the  Zend\\Ldap  namespace, unless otherwise noted.", 
            "title": "API Reference"
        }, 
        {
            "location": "/api/#zend92ldap92ldap", 
            "text": "Zend\\Ldap\\Ldap  is the base interface into a LDAP server. It provides connection and binding\nmethods as well as methods to operate on the LDAP tree.     Method signature  Description      __construct(array|Traversable $options = null) : void  If no options are provided at instantiation, the connection parameters must be passed to the instance using  setOptions() . The allowed options are specified in the  options section .    getResource() : resource  Returns the raw LDAP extension (ext/ldap) resource.    getLastErrorCode() : int  Returns the LDAP error number of the last LDAP command.    getLastError(int  $errorCode = null, array  $errorMessages = null) : string  Returns the LDAP error message of the last LDAP command. The optional  $errorCode  parameter is set to the LDAP error number when given. The optional  $errorMessages  array will be filled with the raw error messages when given. The various LDAP error retrieval functions can return different things, so they are all collected if  $errorMessages  is given.    setOptions(array|Traversable $options) : void  Sets the LDAP connection and binding parameters. Allowed options are specified in the  options section .    getOptions() : array  Returns the current connection and binding parameters.    getBaseDn() : string  Returns the base DN this LDAP connection is bound to.    getCanonicalAccountName(string $acctname, int $form) : string  Returns the canonical account name of the given account name  $acctname .  $form  specifies the format into which the account name is canonicalized. See  Account Name Canonicalization  for more details.    disconnect() : void  Disconnects the instance from the LDAP server.    connect(string $host, int $port, bool $useSsl, bool $useStartTls, int $networkTimeout) : void  Connects the instance to the given LDAP server. All parameters are optional and will be taken from the LDAP connection and binding parameters passed to the instance via the constructor or via  setOptions()  if  null .    bind(string $username, string $password) : void  Authenticates  $username  with  $password  on the LDAP server. If both parameters are omitted, the binding will be carried out with the credentials given in the connection and binding parameters. If no credentials are given in the connection and binding parameters, an anonymous bind will be performed. Note that this requires anonymous binds to be allowed on the LDAP server. An empty string,  '' , can be passed as  $password  together with a username if, and only if,  allowEmptyPassword  is set to  true  in the connection and binding parameters.    search(/* ... */) : Collection  Searches the LDAP tree with the given  $filter  and the given search parameters; see below for full details.    count(string|Filter\\AbstractFilter $filter, string|Dn $basedn, int $scope) : int  Counts the elements returned by the given search parameters. See  search()  for a detailed description of the method parameters.    countChildren(string|Dn $dn) : int  Counts the direct descendants (children) of the entry identified by the given  $dn .    exists(string|Dn $dn) : bool  Checks whether the entry identified by the given  $dn  exists.    searchEntries(/* ... */) : array  Performs a search operation and returns the result as an PHP array. This is essentially the same method as  search()  except for the return type. See  search()  and  searchEntries()  below for more details.    getEntry(string|Dn $dn, array $attributes, bool $throwOnNotFound) : array  Retrieves the LDAP entry identified by  $dn  with the attributes specified in  $attributes . if  $attributes  is omitted, all attributes ( [] ) are included in the result.  $throwOnNotFound  is  false  by default, so the method will return  null  if the specified entry cannot be found. If set to  true , a  Zend\\Ldap\\Exception\\LdapException  will be thrown instead.    prepareLdapEntryArray(array  $entry) : void  Prepare an array for the use in LDAP modification operations. This method does not need to be called by the end-user as it's implicitly called on every data modification method.    add(string|Dn $dn, array $entry) : void  Adds the entry identified by  $dn  with its attributes  $entry  to the LDAP tree. Throws a  Zend\\Ldap\\Exception\\LdapException  if the entry could not be added.    update(string|Dn $dn, array $entry) : void  Updates the entry identified by  $dn  with its attributes  $entry  to the LDAP tree. Throws a  Zend\\Ldap\\Exception\\LdapException  if the entry could not be modified.    save(string|Dn $dn, array $entry) : void  Saves the entry identified by  $dn  with its attributes $entry to the LDAP tree. Throws a  Zend\\Ldap\\Exception\\LdapException  if the entry could not be saved. This method decides by querying the LDAP tree if the entry will be added or updated.    delete(string|Dn $dn, boolean $recursively) : void  Deletes the entry identified by  $dn  from the LDAP tree. Throws a  Zend\\Ldap\\Exception\\LdapException  if the entry could not be deleted.  $recursively  is  false  by default. If set to  true  the deletion will be carried out recursively and will effectively delete a complete subtree. Deletion will fail if $recursively is  false  and the entry  $dn  is not a leaf entry.    moveToSubtree(string|Dn $from, string|Dn $to, bool $recursively, bool $alwaysEmulate) : void  Moves the entry identified by  $from  to a location below  $to  keeping its RDN unchanged.  $recursively  specifies if the operation will be carried out recursively ( false  by default) so that the entry  $from  and all its descendants will be moved. Moving will fail if  $recursively  is  false  and the entry  $from  is not a leaf entry.  $alwaysEmulate  controls whether the ext/ldap function  ldap_rename()  should be used if available. This can only work for leaf entries and for servers and for ext/ldap supporting this function. Set to  true  to always use an emulated rename operation. All move-operations are carried out by copying and then deleting the corresponding entries in the LDAP tree. These operations are not atomic so that failures during the operation will result in an inconsistent state on the LDAP server. The same is true for all recursive operations. They also are by no means atomic. Please keep this in mind.    move(string|Dn $from, string|Dn $to, bool $recursively, bool $alwaysEmulate) : void  This is an alias for  rename() .    rename(string|Dn $from, string|Dn $to, bool $recursively, bool $alwaysEmulate) : void  Renames the entry identified by  $from  to  $to .  $recursively  specifies if the operation will be carried out recursively ( false  by default) so that the entry  $from  and all its descendants will be moved. Moving will fail if  $recursively  is  false  and the entry  $from  is not a leaf entry.  $alwaysEmulate  controls whether the ext/ldap function  ldap_rename()  should be used if available. This can only work for leaf entries and for servers and for ext/ldap supporting this function. Set to  TRUE  to always use an emulated rename operation.    copyToSubtree(string|Dn $from, string|Dn $to, bool $recursively) : void  Copies the entry identified by  $from  to a location below  $to  keeping its RDN unchanged.  $recursively  specifies if the operation will be carried out recursively ( false  by default) so that the entry  $from  and all its descendants will be copied. Copying will fail if  $recursively  is  false  and the entry  $from  is not a leaf entry.    copy(string|Dn $from, string|Dn $to, bool $recursively) : void  Copies the entry identified by  $from  to  $to .  $recursively  specifies if the operation will be carried out recursively ( false  by default) so that the entry  $from  and all its descendants will be copied. Copying will fail if  $recursively  is  false  and the entry  $from  is not a leaf entry.    getNode(string|Dn $dn) : Node  Returns the entry  $dn  wrapped in a  Zend\\Ldap\\Node .    getBaseNode() : Node  Returns the entry for the base DN  $baseDn  wrapped in a  Zend\\Ldap\\Node .    getRootDse() : Node\\RootDse  Returns the RootDSE for the current server.    getSchema() : Node\\Schema  Returns the LDAP schema for the current server.", 
            "title": "Zend\\Ldap\\Ldap"
        }, 
        {
            "location": "/api/#search", 
            "text": "The  search()  signature is as follows:  search(\n    string|Filter\\AbstractFilter $filter,\n    string|Dn $basedn,\n    int $scope,\n    array $attributes,\n    string $sort,\n    string $collectionClass,\n    int $sizelimit,\n    int $timelimit\n) : Collection  where:   $filter : The filter string to be used in the search, e.g.  (objectClass=posixAccount) .  $basedn : The search base for the search. If omitted or  null , the  baseDn \n  from the connection and binding parameters is used.  $scope : The search scope:  Ldap::SEARCH_SCOPE_SUB  searches the complete subtree including the\n   $baseDn  node. This is the default value.  Ldap::SEARCH_SCOPE_ONE  restricts search to one level below  $baseDn .  Ldap::SEARCH_SCOPE_BASE  restricts search to the  $baseDn  itself; this\n  can be used to efficiently retrieve a single entry by its DN.    $attributes : Specifies the attributes contained in the returned entries. To\n  include all possible attributes (ACL restrictions can disallow certain\n  attribute to be retrieved by a given user), pass either an empty array ( [] )\n  or an array containing a wildcard ( ['*'] ) to the method. On some LDAP\n  servers, you can retrieve special internal attributes by passing  ['*', '+'] \n  to the method.  $sort : If given, the result collection will be sorted according to the\n  attribute  $sort . Results can only be sorted after one single attribute as\n  this parameter uses the ext/ldap function  ldap_sort() .  $collectionClass : If given, the result will be wrapped in an object of type\n   $collectionClass . By default, an object of type  Zend\\Ldap\\Collection  will\n  be returned. The custom class must extend  Zend\\Ldap\\Collection , and will be\n  passed a  Zend\\Ldap\\Collection\\Iterator\\Default  on instantiation.  $sizelimit : Enables you to limit the count of entries fetched. Setting this\n  to  0  means no limit.  $timelimit : Sets the maximum number of seconds to spend on the search.\n  Setting this to  0  means no limit.", 
            "title": "search()"
        }, 
        {
            "location": "/api/#searchentries", 
            "text": "searchEntries(\n    string|Dn $basedn,\n    int $scope,\n    array $attributes,\n    string $sort,\n    bool $reverseSort,\n    int $sizelimit,\n    int $timelimit\n) : array  Arguments are essentially the same as for  search() , with two\ndifferences:   $reverseSort : a boolean indicating whether or not the results should be\n  returned in reverse sort order.  $collectionClass  is not present in this signature.   Unlike  search() , this method always returns an array of results.", 
            "title": "searchEntries()"
        }, 
        {
            "location": "/api/#zend92ldap92collection", 
            "text": "Zend\\Ldap\\Collection  implements  Iterator  to allow for item traversal using foreach()  and  Countable  to be able to respond to  count() . With its\nprotected  createEntry()  method, it provides an extension point for developers\nneeding custom result objects.     Method signature  Description      __construct(Collection\\DefaultIterator $iterator) : void  The constructor must be provided with a  Zend\\Ldap\\Collection\\DefaultIterator , which does the real result iteration.    close() : bool  Closes the internal iterator. This is also called in the destructor.    toArray() : array  Returns all entries as an array.    getFirst() : array  Returns the first entry in the collection or  null  if the collection is empty.", 
            "title": "Zend\\Ldap\\Collection"
        }, 
        {
            "location": "/api/#zend92ldap92attribute", 
            "text": "Zend\\Ldap\\Attribute  is a helper class providing only static methods to\nmanipulate arrays suitable to the structure used in  Zend\\Ldap\\Ldap  data\nmodification methods, and to the data format required by the LDAP server. PHP\ndata types are converted using  Zend\\Ldap\\Converter\\Converter  methods.     Method signature  Description      static setAttribute(array  $data, string $attribName, mixed $value, bool $append) : void  Sets the attribute  $attribName  in  $data  to the value  $value . If  $append  is  true  ( false  by default)  $value  will be appended to the attribute.  $value  can be a scalar value or an array of scalar values. Conversion will take place.    static getAttribute(array $data, string $attribName, int|null $index) : array|mixed  Returns the attribute  $attribName  from  $data . If  $index  is  null  (default), an array will be returned containing all the values for the given attribute. An empty array will be returned if the attribute does not exist in the given array. If an integer index is specified the corresponding value at the given index will be returned. If the index is out of bounds,  null  will be returned. Conversion will take place.    static attributeHasValue(array  $data, string $attribName, mixed|array $value) : bool  Checks if the attribute  $attribName  in  $data  has the value(s) given in  $value . The method returns  true  only if all values in  $value  are present in the attribute. Comparison is done strictly (respecting the data type).    static removeDuplicatesFromAttribute(array  $data, string $attribName) : void  Removes all duplicates from the attribute  $attribName  in  $data .    static removeFromAttribute(array  $data, string $attribName, mixed|array $value) : void  Removes the value(s) given in  $value  from the attribute  $attribName  in  $data .    static setPassword(/* ... */) : void  See  setPassword  below for details.    static createPassword(string $password, string $hashType) : string  Creates an LDAP password. The password hash can be specified with  $hashType . The default value here is  Attribute::PASSWORD_HASH_MD5  with  Attribute::PASSWORD_HASH_SHA  as the other possibility.    static setDateTimeAttribute(/  ...  /) : void  See  setDateTimeAttribute()  below for details.    static getDateTimeAttribute(/  ...  /) : array  int", 
            "title": "Zend\\Ldap\\Attribute"
        }, 
        {
            "location": "/api/#setpassword", 
            "text": "The full signature of  setPassword()  is as follows:  static setPassword(\n    array  $data,\n    string $password,\n    string $hashType,\n    string $attribName\n) : void  Sets an LDAP password for the attribute  $attribName  in  $data .  $attribName \ndefaults to  userPassword  which is the standard password attribute. The\npassword hash can be specified with  $hashType . The default value here is Attribute::PASSWORD_HASH_MD5  with  Attribute::PASSWORD_HASH_SHA  as the other\npossibility.", 
            "title": "setPassword()"
        }, 
        {
            "location": "/api/#setdatetimeattribute", 
            "text": "The full signature of  setDateTimeAttribute()  is as follows:  static setDateTimeAttribute(\n    array  $data,\n    string $attribName,\n    int|array $value,\n    boolean $utc,\n    boolean $append\n) : void  Sets the attribute  $attribName  in  $data  to the date/time value  $value . if $append  is  true  ( false  by default)  $value  will be appended to the\nattribute.  $value  can be an integer value or an array of integers.\nDate-time-conversion according to  Converter\\Converter::toLdapDateTime()  will\ntake place.", 
            "title": "setDateTimeAttribute()"
        }, 
        {
            "location": "/api/#getdatetimeattribute", 
            "text": "The full signature of  getDateTimeAttribute()  is as follows:  static getDateTimeAttribute(\n    array $data,\n    string $attribName,\n    int|null $index\n) : array|int  Returns the date/time attribute  $attribName  from  $data . If  $index  is null  (default), an array will be returned containing all the date/time values\nfor the given attribute. An empty array will be returned if the attribute does\nnot exist in the given array. If an integer index is specified the corresponding\ndate/time value at the given index will be returned. If the index is out of\nbounds,  null  will be returned. Date-time-conversion according to Converter\\Converter::fromLdapDateTime()  will take place.", 
            "title": "getDateTimeAttribute()"
        }, 
        {
            "location": "/api/#zend92ldap92converter92converter", 
            "text": "Zend\\Ldap\\Converter\\Converter  is a helper class providing only static methods\nto manipulate arrays suitable to the data format required by the LDAP server.\nPHP data types are converted the following way:   string : No conversion will be done.  integer and float : The value will be converted to a string.  boolean :  true  will be converted to  'TRUE'  and  false  to  'FALSE' .  object and array : The value will be converted to a string by using  serialize() .  Date/Time : The value will be converted to a string with the following\n   date()  format  YmdHisO , UTC timezone ( +0000 ) will be replaced with a  Z .\n  For example  01-30-2011 01:17:32 PM GMT-6  will be  20113001131732-0600  and\n   30-01-2012 15:17:32 UTC  will be  20120130151732Z .  resource : If a stream resource is given, the data will be fetched by calling  stream_get_contents() .  Others: All other data types (namely non-stream resources) will be omitted.   On reading values, the following conversion will take place:   'TRUE' : Converted to  true .  'FALSE' : Converted to  false .  Others: All other strings won't be automatically converted and are passed as they are.      Method signature  Description      static ascToHex32(string $string) : string  Convert all Ascii characters with decimal value less than 32 to hexadecimal value.    static hex32ToAsc(string $string) : string  Convert all hexadecimal characters to Ascii values.    static toLdap(mixed $value, int $type) : string|null  Converts a PHP data type into its LDAP representation.  $type  argument is used to set the conversion method. The default,  Converter::STANDARD , allows the function to try to guess the conversion method to use. Others possibilities are  Converter::BOOLEAN  and  Converter::GENERALIZED_TIME . See the introduction for details.    static fromLdap(string $value, int $type, bool $dateTimeAsUtc) : mixed  Converts an LDAP value into its PHP data type. See introduction and  toLdap()  and  toLdapDateTime()  for details.    static toLdapDateTime(int|string|DateTime $date, bool $asUtc) : string|null  Converts a timestamp, a  DateTime  instance, or a string that is parseable by  strtotime()  into its LDAP date/time representation. If  $asUtc  is  true  ( false  by default), the resulting LDAP date/time string will be in UTC; otherwise a local date/time string will be returned.    static fromLdapDateTime(string $date, boolean $asUtc) : DateTime  Converts LDAP date/time representation into a PHP  DateTime  object.    static toLdapBoolean(bool|int|string $value) : string  Converts a PHP data type into its LDAP boolean representation. By default, always return  false  except if the value is  true ,  'true' , or  1 .    static fromLdapBoolean(string $value) : bool  Converts LDAP boolean representation into a PHP boolean data type.    static toLdapSerialize(mixed $value) : string  The value will be converted to a string by using  serialize() .    static fromLdapUnserialize(string $value) : mixed  The value will be converted from a string by using  unserialize() .", 
            "title": "Zend\\Ldap\\Converter\\Converter"
        }, 
        {
            "location": "/api/#zend92ldap92dn", 
            "text": "Zend\\Ldap\\Dn  provides an object-oriented interface to manipulating LDAP\ndistinguished names (DN). The parameter  $caseFold  that is used in several\nmethods determines the way DN attributes are handled regarding their case.\nAllowed values for this parameter are:   Dn::ATTR_CASEFOLD_NONE : No case-folding will be done.  Dn::ATTR_CASEFOLD_UPPER : All attributes will be converted to upper-case.  Dn::ATTR_CASEFOLD_LOWER : All attributes will be converted to lower-case.   The default case-folding is  Dn::ATTR_CASEFOLD_NONE ; set an alternative with Dn::setDefaultCaseFold() . Each instance of  Zend\\Ldap\\Dn  can have its own\ncase-folding setting. If the  $caseFold  parameter is omitted in method-calls it\ndefaults to the instance's case-folding setting.  The class implements  ArrayAccess  to allow indexer-access to the different\nparts of the DN. The  ArrayAccess  methods proxy to  Dn::get($offset, 1, null) \nfor  offsetGet(int $offset) , to  Dn::set($offset, $value)  for  offsetSet() ,\nand to  Dn::remove($offset, 1)  for  offsetUnset() .  offsetExists()  simply\nchecks if the index is within the bounds.     Method signature  Description      static factory(string|array $dn, string|null $caseFold) : Dn  Creates an instance from an array or a string. The array must conform to the array structure detailed under  Dn::implodeDn() .    static fromString(string $dn, string|null $caseFold) : Dn  Creates an instance from a string.    static fromArray(array $dn, string|null $caseFold) : Dn  Creates an instance from an array. The array must conform to the array structure detailed under  Dn::implodeDn() .    getRdn(string|null $caseFold) : array  Gets the RDN of the current DN. The return value is an array with the RDN attribute names its keys and the RDN attribute values.    getRdnString(string|null $caseFold) : string  Gets the RDN of the current DN. The return value is a string.    getParentDn(integer $levelUp) : Dn  Gets the DN of the current DN\u2019s ancestor  $levelUp  levels up the tree.  $levelUp  defaults to  1 .    get(int $index, int $length, string|null $caseFold) : array  Returns a slice of the current DN determined by  $index  and  $length .  $index  starts with  0  on the DN part from the left.    set(int $index, array $value) : void  Replaces a DN part in the current DN. This operation manipulates the current instance.    remove(int $index, int $length) : void  Removes a DN part from the current DN. This operation manipulates the current instance. $length defaults to 1    append(array $value) : void  Appends a DN part to the current DN. This operation manipulates the current instance.    prepend(array $value) : void  Prepends a DN part to the current DN. This operation manipulates the current instance.    insert(int $index, array $value) : void  Inserts a DN part after the index  $index  to the current DN. This operation manipulates the current instance.    setCaseFold(string|null $caseFold) : void  Sets the case-folding option to the current DN instance. If  $caseFold  is  null , the default case-folding setting is used for the current instance.    toString(string|null $caseFold) : string  Returns DN as a string.    toArray(string|null $caseFold) : array  Returns DN as an array.    __toString() : string  Returns DN as a string; proxies to  Dn::toString(null) .    static setDefaultCaseFold(string $caseFold) : void  Sets the default case-folding option used by all instances on creation by default. Already existing instances are not affected by this setting.    escapeValue(string|array $values) : array  Escapes a DN value according to RFC 2253.    unescapeValue(string|array $values) : array  Undoes the conversion done by  Dn::escapeValue() .    explodeDn(string $dn, array  $keys, array  $vals, string|null $caseFold) : array  Explodes the DN  $dn  into an array containing all parts of the given DN.  $keys  optionally receive DN keys (e.g. CN, OU, DC, ...).  $vals  optionally receive DN values. The resulting array will be of type  [ ['cn' =  'name1', 'uid' =  'user'], ['cn' =  'name2'), ['dc' =  'example'], ['dc' =  'org'] ]  for a DN of  cn=name1+uid=user,cn=name2,dc=example,dc=org .    checkDn(string $dn, array  $keys, array  $vals, string|null $caseFold) : bool  Checks if a given DN  $dn  is malformed. If  $keys  or  $keys  and  $vals  are given, these arrays will be filled with the appropriate DN keys and values.    implodeRdn(array $part, string|null $caseFold) : string  Returns a DN part in the form  $attribute=$value    implodeDn(array $dnArray, string|null $caseFold, string $separator) : string  Implodes an array in the form delivered by  Dn::explodeDn()  to a DN string.   $separator  defaults to  ,  but some LDAP servers also understand  ; .   $dnArray  must of type  [ ['cn' =  'name1', 'uid' =  'user'], ['cn' =  'name2'], ['dc' =  'example'], ['dc' =  'org'] ]    isChildOf(string|Dn $childDn, string|Dn $parentDn) : bool  Checks if given  $childDn  is beneath  $parentDn  subtree.", 
            "title": "Zend\\Ldap\\Dn"
        }, 
        {
            "location": "/api/#zend92ldap92filter", 
            "text": "", 
            "title": "Zend\\Ldap\\Filter"
        }, 
        {
            "location": "/api/#zend92ldap92node", 
            "text": "Zend\\Ldap\\Node  includes the magic property accessors  __set() ,  __get() , __unset() , and  __isset()  for accessing the attributes by name. They proxy to Node::setAttribute() ,  Node::getAttribute() ,  Node::deleteAttribute() , and Node::existsAttribute()  respectively. Furthermore the class implements ArrayAccess  for array-style access to the attributes.  Zend\\Ldap\\Node  also\nimplements  Iterator  and  RecursiveIterator  to allow for recursive\ntree-traversal.     Method signature  Description      static equals(string $attr, string $value) : Filter  Creates an \"equals\" filter:  (attr=value) .    begins(string $attr, string $value) : Filter  Creates a \"begins with\" filter:  (attr=value*) .    ends(string $attr, string $value) : Filter  Creates an \"ends with\" filter:  (attr=*value) .    contains(string $attr, string $value) : Filter  Creates a \"contains\" filter:  (attr=*value*) .    greater(string $attr, string $value) : Filter  Creates a \"greater than\" filter:  (attr value) .    greaterOrEqual(string $attr, string $value) : Filter  Creates a \"greater than or equal\" filter:  (attr =value) .    less(string $attr, string $value) : Filter  Creates a \"less than\" filter:  (attr value) .    lessOrEqual(string $attr, string $value) : Filter  Creates a \"less than or equal\" filter:  (attr =value) .    approx(string $attr, string $value) : Filter  Creates an \"approx\" filter:  (attr~=value) .    any(string $attr) : Filter  Creates an \"any\" filter:  (attr=*) .    string(string $filter) : Filter  Creates a simple custom string filter. The user is responsible for all value-escaping as the filter is used as is.    mask(string $mask, string $value, ...) : Filter  Creates a filter from a string mask. All  $value  parameters will be escaped and substituted into  $mask  by using  sprintf() .    andFilterFilter\\AbstractFilter $filter, ...) : Filter  Creates an \"and\" filter from all arguments given.    orFilter(Filter\\AbstractFilter $filter, ...) : Filter  Creates an \"or\" filter from all arguments given.    __construct(/* ... */) : void  Create an arbitrary filter according to the parameters supplied; see the  Node constructor  below for the full signature.    toString() : string  Returns a string representation of the filter.    __toString() : string  Returns a string representation of the filter. Proxies to  Filter::toString() .    negate() : Filter\\NotFilter  Creates and returns a new filter that is a negation of the current filter.    addAnd(Filter\\AbstractFilter $filter, ...) : Filter\\AndFilter  Creates an \"and\" filter from the current filter and all filters passed in as the arguments.    addOr(Filter\\AbstractFilter $filter, ...) : Filter\\OrFilter  Creates an \"or\" filter from the current filter and all filters passed in as the arguments.    escapeValue(string|array $values) : string|array  Escapes the given  $values  according to RFC 2254 so that they can be safely used in LDAP filters. If a single string is given, a string is returned, otherwise an array is returned.  Any control characters with an ASCII code   32  as well as characters with special meaning in LDAP filters ( * ,  ( ,  ) , and  \\\\  (the backslash)) are converted into the representation of a backslash followed by two hex digits representing the hexadecimal value of the character.    unescapeValue(string|array $values) : string|array  Undoes the conversion done by  Filter::escapeValue() . Converts any sequences of a backslash followed by two hex digits into the corresponding character.", 
            "title": "Zend\\Ldap\\Node"
        }, 
        {
            "location": "/api/#node-constructor", 
            "text": "The full signature of the  Zend\\Ldap\\Node  constructor is:  __construct(\n    string $attr,\n    string $value,\n    string $filtertype,\n    string|null $prepend,\n    string|null $append\n) : void  The resulting filter will be a concatenation of  $attr ,  $filtertype , $prepend ,  $value , and  $append . Normally this constructor is not needed, as\nall filters can be created by using the appropriate factory methods.", 
            "title": "Node constructor"
        }, 
        {
            "location": "/api/#zend92ldap92node92rootdse", 
            "text": "The following methods are available on all vendor-specific subclasses.  Zend\\Ldap\\Node\\RootDse  includes the magic property accessors  __get()  and __isset()  to access the attributes by their name. They proxy to Node\\RootDse::getAttribute()  and  Node\\RootDse::existsAttribute() \nrespectively.  __set()  and  __unset()  are also implemented but they throw a BadMethodCallException , as modifications are not allowed on RootDSE nodes.\nFurthermore the class implements  ArrayAccess  for array-style access to the\nattributes.   offsetSet()  and  offsetUnset()  also throw a BadMethodCallException .     Method signature  Description      getDn() : Dn  Gets the DN of the current node as a  Zend\\Ldap\\Dn  instance.    getDnString(string $caseFold) : string  Gets the DN of the current node as a string.    getDnArray(string $caseFold) : array  Gets the DN of the current node as an array.    getRdnString(string $caseFold) : string  Gets the RDN of the current node as a string.    getRdnArray(string $caseFold) : array  Gets the RDN of the current node as an array.    getObjectClass() : array  Returns the  objectClass  of the node.    toString() : string  Returns the DN of the current node; proxies to  Zend\\Ldap\\Dn::getDnString() .    __toString() : string  Casts to string representation; proxies to  Zend\\Ldap\\Dn::toString() .    toArray(bool $includeSystemAttributes) : array  Returns an array representation of the current node. If  $includeSystemAttributes  is  false  (defaults to  true ), the system specific attributes are stripped from the array. Unlike  getAttributes() , the resulting array contains the DN with key \u2018dn\u2019.    toJson(bool $includeSystemAttributes) : string  Returns a JSON representation of the current node using  toArray() .    getData(bool $includeSystemAttributes) : array  Returns the node's attributes. The array contains all attributes in its internal format (no conversion).    existsAttribute(string $name, bool $emptyExists) : bool  Checks whether a given attribute exists. If  $emptyExists  is  false , empty attributes (containing only  [] ) are treated as non-existent, returning  false . If  $emptyExists  is  true , empty attributes are treated as existent, returning  true . In this case, the method returns  false  only if the attribute name is missing in the key-collection.    attributeHasValue(string $name, mixed|array $value) : bool  Checks if the given value(s) exist in the attribute. The method returns  true  only if all values in  $value  are present in the attribute. Comparison is done strictly (respecting the data type).    count() : int  Returns the number of attributes in the node. Implements  Countable .    getAttribute(string $name, int|null $index) : mixed  Gets an LDAP attribute. Data conversion is applied using  Attribute::getAttribute() .    getAttributes(bool $includeSystemAttributes) : array  Gets all attributes of node. If  $includeSystemAttributes  is  false  (defaults to  true ), the system specific attributes are stripped from the array.    getDateTimeAttribute(string $name, int|null $index) : array|int  Gets an LDAP date/time attribute. Data conversion is applied using  Attribute::getDateTimeAttribute() .    reload(Ldap $ldap) : void  Reloads the current node's attributes from the given LDAP server.    static create(Ldap $ldap) : RootDse  Factory method to create the RootDSE.    getNamingContexts() : array  Gets the  namingContexts .    getSubschemaSubentry() : string|null  Gets the  subschemaSubentry .    supportsVersion(string|int|array $versions) : bool  Determines if the LDAP version is supported.    supportsSaslMechanism(string|array $mechlist) : bool  Determines if the SASL mechanism is supported.    getServerType() : int  Gets the server type. Returns  RootDse::SERVER_TYPE_GENERIC  for unknown LDAP servers,  RootDse::SERVER_TYPE_OPENLDAP  for OpenLDAP servers,  RootDse::SERVER_TYPE_ACTIVEDIRECTORY  for Microsoft ActiveDirectory servers, and  RootDse::SERVER_TYPE_EDIRECTORY  for Novell eDirectory servers.    getSchemaDn() : Dn  Returns the schema DN.", 
            "title": "Zend\\Ldap\\Node\\RootDse"
        }, 
        {
            "location": "/api/#openldap", 
            "text": "Additionally the common methods above apply to instances of  Zend\\Ldap\\Node\\RootDse\\OpenLdap .  Refer to  LDAP Operational Attributes and Objects \nspecification for information on the attributes of OpenLDAP RootDSE.     Method signature  Description      getServerType() : int  Gets the server type. Returns  Zend\\Ldap\\Node\\RootDse::SERVER_TYPE_OPENLDAP    getConfigContext() : string|null  Gets the  configContext .    getMonitorContext() : string|null  Gets the  monitorContext .    supportsControl(string|array $oids) : bool  Determines if the control is supported.    supportsExtension(string|array $oids) : bool  Determines if the extension is supported.    supportsFeature(string|array $oids) : bool  Determines if the feature is supported.", 
            "title": "OpenLDAP"
        }, 
        {
            "location": "/api/#activedirectory", 
            "text": "Additionally the common methods above apply to instances of Zend\\Ldap\\Node\\RootDse\\ActiveDirectory .  Refer to the  RootDSE \nspecification for information on the attributes of Microsoft ActiveDirectory\nRootDSE.     Method signature  Description      getServerType() : int  Gets the server type. Returns  Zend\\Ldap\\Node\\RootDse::SERVER_TYPE_ACTIVEDIRECTORY    getConfigurationNamingContext() : string|null  Gets the  configurationNamingContext .    getCurrentTime() : string|null  Gets the  currentTime .    getDefaultNamingContext() : string|null  Gets the  defaultNamingContext .    getDnsHostName() : string|null  Gets the  dnsHostName .    getDomainControllerFunctionality() : string|null  Gets the  domainControllerFunctionality .    getDomainFunctionality() : string|null  Gets the  domainFunctionality .    getDsServiceName() : string|null  Gets the  dsServiceName .    getForestFunctionality() : string|null  Gets the  forestFunctionality .    getHighestCommittedUSN() : string|null  Gets the  highestCommittedUSN .    getIsGlobalCatalogReady() : string|null  Gets the  isGlobalCatalogReady .    getIsSynchronized() : string|null  Gets the  isSynchronized .    getLdapServiceName() : string|null  Gets the  ldapServiceName .    getRootDomainNamingContext() : string|null  Gets the  rootDomainNamingContext .    getSchemaNamingContext() : string|null  Gets the  schemaNamingContext .    getServerName() : string|null  Gets the  serverName .    supportsCapability(string|array $oids) : bool  Determines if the capability is supported.    supportsControl(string|array $oids) : bool  Determines if the control is supported.    supportsPolicy(string|array $policies) : bool  Determines if the version is supported.", 
            "title": "ActiveDirectory"
        }, 
        {
            "location": "/api/#edirectory", 
            "text": "Additionally the common methods above apply to instances of Zend\\Ldap\\Node\\RootDse\\eDirectory .  Refer to  Getting Information about the LDAP Server \nfor information on the attributes of Novell eDirectory RootDSE.     Method signature  Description      getServerType() : int  Gets the server type. Returns  Zend\\Ldap\\Node\\RootDse::SERVER_TYPE_EDIRECTORY    supportsExtension(string|array $oids) : bool  Determines if the extension is supported.    getVendorName() : string|null  Gets the  vendorName .    getVendorVersion() : string|null  Gets the  vendorVersion .    getDsaName() : string|null  Gets the  dsaName .    getStatisticsErrors() : string|null  Gets the server statistics  errors .    getStatisticsSecurityErrors() : string|null  Gets the server statistics  securityErrors .    getStatisticsChainings() : string|null  Gets the server statistics  chainings .    getStatisticsReferralsReturned() : string|null  Gets the server statistics  referralsReturned .    getStatisticsExtendedOps() : string|null  Gets the server statistics  extendedOps .    getStatisticsAbandonOps() : string|null  Gets the server statistics  abandonOps .    getStatisticsWholeSubtreeSearchOps() : string|null  Gets the server statistics  wholeSubtreeSearchOps .", 
            "title": "eDirectory"
        }, 
        {
            "location": "/api/#zend92ldap92node92schema", 
            "text": "The following methods are available on all vendor-specific subclasses.  Zend\\Ldap\\Node\\Schema  includes the magic property accessors  __get()  and  __isset()  to access\nthe attributes by their name. They proxy to  Schema::getAttribute()  and Schema::existsAttribute()  respectively.  __set()  and  __unset()  are also\nimplemented, but they throw a  BadMethodCallException , as modifications are not allowed on RootDSE\nnodes. Furthermore the class implements  ArrayAccess  for array-style access to the attributes. offsetSet()  and  offsetUnset()  also throw a  BadMethodCallException .     Method signature  Description      getDn() : Dn  Gets the DN of the current node as a  Zend\\Ldap\\Dn  instance.    getDnString(string $caseFold) : string  Gets the DN of the current node as a string.    getDnArray(string $caseFold) : array  Gets the DN of the current node as an array.    getRdnString(string $caseFold) : string  Gets the RDN of the current node as a string.    getRdnArray(string $caseFold) : array  Gets the RDN of the current node as an array.    getObjectClass() : array  Returns the  objectClass  of the node.    toString() : string  Returns the DN of the current node; proxies to  Zend\\Ldap\\Dn::getDnString() .    __toString() : string  Casts to string representation; proxies to  Zend\\Ldap\\Dn::toString() .    toArray(bool $includeSystemAttributes) : array  Returns an array representation of the current node. If  $includeSystemAttributes  is  false  (defaults to  true ), the system specific attributes are stripped from the array. Unlike  Node\\Schema::getAttributes() , the resulting array contains the DN with key  dn .    toJson(bool $includeSystemAttributes) : string  Returns a JSON representation of the current node using  Node\\Schema::toArray() .    getData(bool $includeSystemAttributes) : array  Returns the node\u2019s attributes. The array contains all attributes in its internal format (no conversion).    existsAttribute(string $name, bool $emptyExists) : bool  Checks whether a given attribute exists. If  $emptyExists  is  false , empty attributes (containing only  [] ) are treated as non-existent, returning  false . If  $emptyExists  is  true , empty attributes are treated as existent, returning  true . In this case, the method returns  false  only if the attribute name is missing in the key-collection.    attributeHasValue(string $name, mixed|array $value) : bool  Checks if the given value(s) exist in the attribute. The method returns  true  only if all values in $value are present in the attribute. Comparison is done strictly (respecting the data type).    count() : int  Returns the number of attributes in the node. Implements  Countable .    getAttribute(string $name, int|null $index) : mixed  Gets an LDAP attribute.  Data conversion is applied using  Attribute::getAttribute() .    getAttributes(bool $includeSystemAttributes) : array  Gets all attributes of node. If  $includeSystemAttributes  is  false  (defaults to  true ) the system specific attributes are stripped from the array.    getDateTimeAttribute(string $name, int|null $index) : array|int  Gets a LDAP date/time attribute. Data conversion is applied using  Attribute::getDateTimeAttribute() .    reload(Ldap $ldap) : void  Reloads the current node\u2019s attributes from the given LDAP server.    static create(Ldap $ldap) : Node\\Schema  Factory method to create the  Schema  node.    getAttributeTypes() : array  Gets the attribute types as an array.    getObjectClasses() : array  Gets the object classes as an array of  Zend\\Ldap\\Node\\Schema\\ObjectClass\\ObjectClassInterface  instances.", 
            "title": "Zend\\Ldap\\Node\\Schema"
        }, 
        {
            "location": "/api/#attributetypeinterface", 
            "text": "Method signature  Description      getName() : string  Gets the attribute name.    getOid() : string  Gets the attribute OID.    getSyntax() : string  Gets the attribute syntax.    getMaxLength() : int|null  Gets the attribute maximum length.    isSingleValued() : bool  Returns if the attribute is single-valued.    getDescription() : string  Gets the attribute description", 
            "title": "AttributeTypeInterface"
        }, 
        {
            "location": "/api/#objectclassinterface", 
            "text": "Method signature  Description      getName() : string  Returns the objectClass name.    getOid() : string  Returns the objectClass OID.    getMustContain() : array  Returns the attributes that this objectClass must contain.    getMayContain() : array  Returns the attributes that this objectClass may contain.    getDescription() : string  Returns the attribute description    getType() : int  Returns the  objectClass  type. The method returns one of the following values:  Schema::OBJECTCLASS_TYPE_UNKNOWN  for unknown class types,  Schema::OBJECTCLASS_TYPE_STRUCTURAL  for structural classes,  Schema::OBJECTCLASS_TYPE_ABSTRACT  for abstract classes,  Schema::OBJECTCLASS_TYPE_AUXILIARY  for auxiliary classes.    getParentClasses() : array  Returns the parent  objectClass es of this class. This includes structural, abstract and auxiliary  objectClass es.", 
            "title": "ObjectClassInterface"
        }, 
        {
            "location": "/api/#abstractitem", 
            "text": "Classes representing attribute types and object classes extend Zend\\Ldap\\Node\\Schema\\AbstractItem , which provides some core methods to access\narbitrary attributes on the underlying LDAP node.   AbstractItem  includes the\nmagic property accessors  __get()  and  __isset()  to access the attributes by\ntheir name. Furthermore the class implements  ArrayAccess  for\narray-style-access to the attributes.  offsetSet()  and  offsetUnset()  throw a BadMethodCallException , as modifications are not allowed on schema information\nnodes.     Method signature  Description      getData() : array  Gets all the underlying data from the schema information node.    count() : int  Returns the number of attributes in this schema information node. Implements  Countable .", 
            "title": "AbstractItem"
        }, 
        {
            "location": "/api/#openldap_1", 
            "text": "Additionally the common methods above apply to instances of Zend\\Ldap\\Node\\Schema\\OpenLDAP .     Method signature  Description      getLdapSyntaxes() : array  Gets the LDAP syntaxes.    getMatchingRules() : array  Gets the matching rules.    getMatchingRuleUse() : array  Gets the matching rule use.     Zend\\Ldap\\Node\\Schema\\AttributeType\\OpenLDAP  has the following API:     Method signature  Description      getParent() : Node\\Schema\\AttributeType\\OpenLdap|null  Returns the parent attribute type in the inheritance tree if one exists.     Zend\\Ldap\\Node\\Schema\\ObjectClass\\OpenLDAP  has the following API:     Method signature  Description      getParents() : array  Returns the parent object classes in the inheritance tree if one exists. The returned array is an array of  Zend\\Ldap\\Node\\Schema\\ObjectClass\\OpenLdap .", 
            "title": "OpenLDAP"
        }, 
        {
            "location": "/api/#activedirectory_1", 
            "text": "", 
            "title": "ActiveDirectory"
        }, 
        {
            "location": "/api/#schema-browsing-on-activedirectory-servers", 
            "text": "Due to restrictions on Microsoft ActiveDirectory servers regarding the number\nof entries returned by generic search routines, and due to the structure of\nthe ActiveDirectory schema repository, schema browsing is currently  not \navailable for Microsoft ActiveDirectory servers.   None of  Zend\\Ldap\\Node\\Schema\\ActiveDirectory , Zend\\Ldap\\Node\\Schema\\AttributeType\\ActiveDirectory , or Zend\\Ldap\\Node\\Schema\\\\ObjectClass\\ActiveDirectory  provide additional\nmethods.", 
            "title": "Schema browsing on ActiveDirectory servers"
        }, 
        {
            "location": "/api/#zend92ldap92ldif92encoder", 
            "text": "Method signature  Description      decode(string $string) : array  Decodes the string  $string  into an array of LDIF items.    encode(scalar|array|Node $value, array $options) : string  Encode  $value  into a LDIF representation.     The  $options  argument to  encode()  may contain the following keys:   sort : Sort the given attributes with dn following  objectClass , and\n  following all other attributes sorted alphabetically.  true  by default.  version : The LDIF format version.  1  by default.  wrap : The line-length.  78  by default to conform to the LDIF specification.", 
            "title": "Zend\\Ldap\\Ldif\\Encoder"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage Scenarios\n\n\nAuthentication scenarios\n\n\nOpenLDAP\n\n\n\n\nTODO\n\n\n\n\nActiveDirectory\n\n\n\n\nTODO\n\n\n\n\nBasic CRUD operations\n\n\nRetrieving data from the LDAP\n\n\nGetting an entry by its DN\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n$hm = $ldap-\ngetEntry('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local');\n\n/*\n$hm is an array of the following structure:\n[\n    'dn'          =\n 'cn=Hugo M\u00fcller,ou=People,dc=my,dc=local',\n    'cn'          =\n ['Hugo M\u00fcller'],\n    'sn'          =\n ['M\u00fcller'],\n    'objectclass' =\n ['inetOrgPerson', 'top'],\n    ...\n]\n*/\n\n\n\nCheck for the existence of a given DN\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n$isThere = $ldap-\nexists('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local');\n\n\n\nCount children of a given DN\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n$childrenCount = $ldap-\ncountChildren('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local');\n\n\n\nSearching the LDAP tree\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n$result = $ldap-\nsearch(\n    '(objectclass=*)',\n    'ou=People,dc=my,dc=local',\n    Ldap::SEARCH_SCOPE_ONE\n);\n\nforeach ($result as $item) {\n    echo $item[\ndn\n] . ': ' . $item['cn'][0] . PHP_EOL;\n}\n\n\n\nAdding data to the LDAP\n\n\nAdd a new entry to the LDAP\n\n\nuse Zend\\Ldap\\Attribute;\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n\n$entry = [];\nAttribute::setAttribute($entry, 'cn', 'Hans Meier');\nAttribute::setAttribute($entry, 'sn', 'Meier');\nAttribute::setAttribute($entry, 'objectClass', 'inetOrgPerson');\n\n$ldap-\nadd('cn=Hans Meier,ou=People,dc=my,dc=local', $entry);\n\n\n\nDeleting from the LDAP\n\n\nDelete an existing entry from the LDAP\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n$ldap-\ndelete('cn=Hans Meier,ou=People,dc=my,dc=local');\n\n\n\nUpdating the LDAP\n\n\nUpdate an existing entry on the LDAP\n\n\nuse Zend\\Ldap\\Attribute;\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n\n$hm = $ldap-\ngetEntry('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local');\nAttribute::setAttribute($hm, 'mail', 'mueller@my.local');\nAttribute::setPassword($hm, 'newPa$$w0rd', Attribute::PASSWORD_HASH_SHA1);\n\n$ldap-\nupdate('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local', $hm);\n\n\n\nExtended operations\n\n\nCopy and move entries in the LDAP\n\n\nCopy a LDAP entry recursively with all its descendants\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n$ldap-\ncopy(\n    'cn=Hugo M\u00fcller,ou=People,dc=my,dc=local',\n    'cn=Hans Meier,ou=People,dc=my,dc=local',\n    true\n);\n\n\n\nMove a LDAP entry recursively with all its descendants to a different subtree\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n$ldap-\nmoveToSubtree(\n    'cn=Hugo M\u00fcller,ou=People,dc=my,dc=local',\n    'ou=Dismissed,dc=my,dc=local',\n    true\n);", 
            "title": "Usage Scenarios"
        }, 
        {
            "location": "/usage/#usage-scenarios", 
            "text": "", 
            "title": "Usage Scenarios"
        }, 
        {
            "location": "/usage/#authentication-scenarios", 
            "text": "", 
            "title": "Authentication scenarios"
        }, 
        {
            "location": "/usage/#openldap", 
            "text": "TODO", 
            "title": "OpenLDAP"
        }, 
        {
            "location": "/usage/#activedirectory", 
            "text": "TODO", 
            "title": "ActiveDirectory"
        }, 
        {
            "location": "/usage/#basic-crud-operations", 
            "text": "", 
            "title": "Basic CRUD operations"
        }, 
        {
            "location": "/usage/#retrieving-data-from-the-ldap", 
            "text": "", 
            "title": "Retrieving data from the LDAP"
        }, 
        {
            "location": "/usage/#getting-an-entry-by-its-dn", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n$hm = $ldap- getEntry('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local');\n\n/*\n$hm is an array of the following structure:\n[\n    'dn'          =  'cn=Hugo M\u00fcller,ou=People,dc=my,dc=local',\n    'cn'          =  ['Hugo M\u00fcller'],\n    'sn'          =  ['M\u00fcller'],\n    'objectclass' =  ['inetOrgPerson', 'top'],\n    ...\n]\n*/", 
            "title": "Getting an entry by its DN"
        }, 
        {
            "location": "/usage/#check-for-the-existence-of-a-given-dn", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n$isThere = $ldap- exists('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local');", 
            "title": "Check for the existence of a given DN"
        }, 
        {
            "location": "/usage/#count-children-of-a-given-dn", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n$childrenCount = $ldap- countChildren('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local');", 
            "title": "Count children of a given DN"
        }, 
        {
            "location": "/usage/#searching-the-ldap-tree", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n$result = $ldap- search(\n    '(objectclass=*)',\n    'ou=People,dc=my,dc=local',\n    Ldap::SEARCH_SCOPE_ONE\n);\n\nforeach ($result as $item) {\n    echo $item[ dn ] . ': ' . $item['cn'][0] . PHP_EOL;\n}", 
            "title": "Searching the LDAP tree"
        }, 
        {
            "location": "/usage/#adding-data-to-the-ldap", 
            "text": "", 
            "title": "Adding data to the LDAP"
        }, 
        {
            "location": "/usage/#add-a-new-entry-to-the-ldap", 
            "text": "use Zend\\Ldap\\Attribute;\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n\n$entry = [];\nAttribute::setAttribute($entry, 'cn', 'Hans Meier');\nAttribute::setAttribute($entry, 'sn', 'Meier');\nAttribute::setAttribute($entry, 'objectClass', 'inetOrgPerson');\n\n$ldap- add('cn=Hans Meier,ou=People,dc=my,dc=local', $entry);", 
            "title": "Add a new entry to the LDAP"
        }, 
        {
            "location": "/usage/#deleting-from-the-ldap", 
            "text": "", 
            "title": "Deleting from the LDAP"
        }, 
        {
            "location": "/usage/#delete-an-existing-entry-from-the-ldap", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n$ldap- delete('cn=Hans Meier,ou=People,dc=my,dc=local');", 
            "title": "Delete an existing entry from the LDAP"
        }, 
        {
            "location": "/usage/#updating-the-ldap", 
            "text": "", 
            "title": "Updating the LDAP"
        }, 
        {
            "location": "/usage/#update-an-existing-entry-on-the-ldap", 
            "text": "use Zend\\Ldap\\Attribute;\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n\n$hm = $ldap- getEntry('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local');\nAttribute::setAttribute($hm, 'mail', 'mueller@my.local');\nAttribute::setPassword($hm, 'newPa$$w0rd', Attribute::PASSWORD_HASH_SHA1);\n\n$ldap- update('cn=Hugo M\u00fcller,ou=People,dc=my,dc=local', $hm);", 
            "title": "Update an existing entry on the LDAP"
        }, 
        {
            "location": "/usage/#extended-operations", 
            "text": "", 
            "title": "Extended operations"
        }, 
        {
            "location": "/usage/#copy-and-move-entries-in-the-ldap", 
            "text": "", 
            "title": "Copy and move entries in the LDAP"
        }, 
        {
            "location": "/usage/#copy-a-ldap-entry-recursively-with-all-its-descendants", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n$ldap- copy(\n    'cn=Hugo M\u00fcller,ou=People,dc=my,dc=local',\n    'cn=Hans Meier,ou=People,dc=my,dc=local',\n    true\n);", 
            "title": "Copy a LDAP entry recursively with all its descendants"
        }, 
        {
            "location": "/usage/#move-a-ldap-entry-recursively-with-all-its-descendants-to-a-different-subtree", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n$ldap- moveToSubtree(\n    'cn=Hugo M\u00fcller,ou=People,dc=my,dc=local',\n    'ou=Dismissed,dc=my,dc=local',\n    true\n);", 
            "title": "Move a LDAP entry recursively with all its descendants to a different subtree"
        }, 
        {
            "location": "/tools/", 
            "text": "Tools\n\n\nCreation and modification of DN strings\n\n\nUsing the filter API to create search filters\n\n\nCreate simple LDAP filters\n\n\nuse Zend\\Ldap\\Filter;\n\n$f1  = Filter::equals('name', 'value');         // (name=value)\n$f2  = Filter::begins('name', 'value');         // (name=value*)\n$f3  = Filter::ends('name', 'value');           // (name=*value)\n$f4  = Filter::contains('name', 'value');       // (name=*value*)\n$f5  = Filter::greater('name', 'value');        // (name\nvalue)\n$f6  = Filter::greaterOrEqual('name', 'value'); // (name\n=value)\n$f7  = Filter::less('name', 'value');           // (name\nvalue)\n$f8  = Filter::lessOrEqual('name', 'value');    // (name\n=value)\n$f9  = Filter::approx('name', 'value');         // (name~=value)\n$f10 = Filter::any('name');                     // (name=*)\n\n\n\nCreate more complex LDAP filters\n\n\nuse Zend\\Ldap\\Filter;\n\n$f1 = Filter::ends('name', 'value')-\nnegate(); // (!(name=*value))\n\n$f2 = Filter::equals('name', 'value');\n$f3 = Filter::begins('name', 'value');\n$f4 = Filter::ends('name', 'value');\n\n// (\n(name=value)(name=value*)(name=*value))\n$f5 = Filter::andFilter($f2, $f3, $f4);\n\n// (|(name=value)(name=value*)(name=*value))\n$f6 = Filter::orFilter($f2, $f3, $f4);\n\n\n\nModify LDAP entries using the Attribute API\n\n\n\n\nTODO", 
            "title": "Tools"
        }, 
        {
            "location": "/tools/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/tools/#creation-and-modification-of-dn-strings", 
            "text": "", 
            "title": "Creation and modification of DN strings"
        }, 
        {
            "location": "/tools/#using-the-filter-api-to-create-search-filters", 
            "text": "", 
            "title": "Using the filter API to create search filters"
        }, 
        {
            "location": "/tools/#create-simple-ldap-filters", 
            "text": "use Zend\\Ldap\\Filter;\n\n$f1  = Filter::equals('name', 'value');         // (name=value)\n$f2  = Filter::begins('name', 'value');         // (name=value*)\n$f3  = Filter::ends('name', 'value');           // (name=*value)\n$f4  = Filter::contains('name', 'value');       // (name=*value*)\n$f5  = Filter::greater('name', 'value');        // (name value)\n$f6  = Filter::greaterOrEqual('name', 'value'); // (name =value)\n$f7  = Filter::less('name', 'value');           // (name value)\n$f8  = Filter::lessOrEqual('name', 'value');    // (name =value)\n$f9  = Filter::approx('name', 'value');         // (name~=value)\n$f10 = Filter::any('name');                     // (name=*)", 
            "title": "Create simple LDAP filters"
        }, 
        {
            "location": "/tools/#create-more-complex-ldap-filters", 
            "text": "use Zend\\Ldap\\Filter;\n\n$f1 = Filter::ends('name', 'value')- negate(); // (!(name=*value))\n\n$f2 = Filter::equals('name', 'value');\n$f3 = Filter::begins('name', 'value');\n$f4 = Filter::ends('name', 'value');\n\n// ( (name=value)(name=value*)(name=*value))\n$f5 = Filter::andFilter($f2, $f3, $f4);\n\n// (|(name=value)(name=value*)(name=*value))\n$f6 = Filter::orFilter($f2, $f3, $f4);", 
            "title": "Create more complex LDAP filters"
        }, 
        {
            "location": "/tools/#modify-ldap-entries-using-the-attribute-api", 
            "text": "TODO", 
            "title": "Modify LDAP entries using the Attribute API"
        }, 
        {
            "location": "/node/", 
            "text": "Object-oriented access to the LDAP tree using Zend\\Ldap\\Node\n\n\nBasic CRUD operations\n\n\nRetrieving data from the LDAP\n\n\n\n\nTODO\n\n\n\n\nGetting a node by its DN\n\n\n\n\nTODO\n\n\n\n\nSearching a node's subtree\n\n\n\n\nTODO\n\n\n\n\nAdding a new node to the LDAP\n\n\n\n\nTODO\n\n\n\n\nDeleting a node from the LDAP\n\n\n\n\nTODO\n\n\n\n\nUpdating a node on the LDAP\n\n\n\n\nTODO\n\n\n\n\nExtended operations\n\n\nCopy and move nodes in the LDAP\n\n\n\n\nTODO\n\n\n\n\nTree traversal\n\n\nTraverse LDAP tree recursively\n\n\nuse RecursiveIteratorIterator;\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap-\nbind();\n$ri = new RecursiveIteratorIterator(\n    $ldap-\ngetBaseNode(),\n    RecursiveIteratorIterator::SELF_FIRST\n);\n\nforeach ($ri as $rdn =\n $n) {\n    var_dump($n);\n}", 
            "title": "Object-oriented access to the LDAP tree"
        }, 
        {
            "location": "/node/#object-oriented-access-to-the-ldap-tree-using-zend92ldap92node", 
            "text": "", 
            "title": "Object-oriented access to the LDAP tree using Zend\\Ldap\\Node"
        }, 
        {
            "location": "/node/#basic-crud-operations", 
            "text": "", 
            "title": "Basic CRUD operations"
        }, 
        {
            "location": "/node/#retrieving-data-from-the-ldap", 
            "text": "TODO", 
            "title": "Retrieving data from the LDAP"
        }, 
        {
            "location": "/node/#getting-a-node-by-its-dn", 
            "text": "TODO", 
            "title": "Getting a node by its DN"
        }, 
        {
            "location": "/node/#searching-a-nodes-subtree", 
            "text": "TODO", 
            "title": "Searching a node's subtree"
        }, 
        {
            "location": "/node/#adding-a-new-node-to-the-ldap", 
            "text": "TODO", 
            "title": "Adding a new node to the LDAP"
        }, 
        {
            "location": "/node/#deleting-a-node-from-the-ldap", 
            "text": "TODO", 
            "title": "Deleting a node from the LDAP"
        }, 
        {
            "location": "/node/#updating-a-node-on-the-ldap", 
            "text": "TODO", 
            "title": "Updating a node on the LDAP"
        }, 
        {
            "location": "/node/#extended-operations", 
            "text": "", 
            "title": "Extended operations"
        }, 
        {
            "location": "/node/#copy-and-move-nodes-in-the-ldap", 
            "text": "TODO", 
            "title": "Copy and move nodes in the LDAP"
        }, 
        {
            "location": "/node/#tree-traversal", 
            "text": "", 
            "title": "Tree traversal"
        }, 
        {
            "location": "/node/#traverse-ldap-tree-recursively", 
            "text": "use RecursiveIteratorIterator;\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$ldap- bind();\n$ri = new RecursiveIteratorIterator(\n    $ldap- getBaseNode(),\n    RecursiveIteratorIterator::SELF_FIRST\n);\n\nforeach ($ri as $rdn =  $n) {\n    var_dump($n);\n}", 
            "title": "Traverse LDAP tree recursively"
        }, 
        {
            "location": "/server/", 
            "text": "Getting information from the LDAP server\n\n\nRootDSE\n\n\nSee the following documents for more information on the attributes contained\nwithin the RootDSE for a given LDAP server.\n\n\n\n\nOpenLDAP\n\n\nMicrosoft ActiveDirectory\n\n\nNovell eDirectory\n\n\n\n\nGetting hands on the RootDSE\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$rootdse = $ldap-\ngetRootDse();\n$serverType = $rootdse-\ngetServerType();\n\n\n\nSchema Browsing\n\n\nGetting hands on the server schema\n\n\nuse Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$schema = $ldap-\ngetSchema();\n$classes = $schema-\ngetObjectClasses();\n\n\n\nOpenLDAP\n\n\n\n\nTODO\n\n\n\n\nActiveDirectory\n\n\nDue to restrictions on Microsoft ActiveDirectory servers regarding the number of\nentries returned by generic search routines and due to the structure of the\nActiveDirectory schema repository, schema browsing is currently \nnot\n\navailable for Microsoft ActiveDirectory servers.", 
            "title": "Getting information from the LDAP server"
        }, 
        {
            "location": "/server/#getting-information-from-the-ldap-server", 
            "text": "", 
            "title": "Getting information from the LDAP server"
        }, 
        {
            "location": "/server/#rootdse", 
            "text": "See the following documents for more information on the attributes contained\nwithin the RootDSE for a given LDAP server.   OpenLDAP  Microsoft ActiveDirectory  Novell eDirectory", 
            "title": "RootDSE"
        }, 
        {
            "location": "/server/#getting-hands-on-the-rootdse", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$rootdse = $ldap- getRootDse();\n$serverType = $rootdse- getServerType();", 
            "title": "Getting hands on the RootDSE"
        }, 
        {
            "location": "/server/#schema-browsing", 
            "text": "", 
            "title": "Schema Browsing"
        }, 
        {
            "location": "/server/#getting-hands-on-the-server-schema", 
            "text": "use Zend\\Ldap\\Ldap;\n\n$options = [/* ... */];\n$ldap = new Ldap($options);\n$schema = $ldap- getSchema();\n$classes = $schema- getObjectClasses();", 
            "title": "Getting hands on the server schema"
        }, 
        {
            "location": "/server/#openldap", 
            "text": "TODO", 
            "title": "OpenLDAP"
        }, 
        {
            "location": "/server/#activedirectory", 
            "text": "Due to restrictions on Microsoft ActiveDirectory servers regarding the number of\nentries returned by generic search routines and due to the structure of the\nActiveDirectory schema repository, schema browsing is currently  not \navailable for Microsoft ActiveDirectory servers.", 
            "title": "ActiveDirectory"
        }, 
        {
            "location": "/ldif/", 
            "text": "Serializing LDAP data to and from LDIF\n\n\nSerialize a LDAP entry to LDIF\n\n\nuse Zend\\Ldap\\Ldif\\Encoder;\n\n$data = [\n    'dn'                         =\n 'uid=rogasawara,ou=\u55b6\u696d\u90e8,o=Airius',\n    'objectclass'                =\n [\n        'top',\n        'person',\n        'organizationalPerson',\n        'inetOrgPerson',\n    ],\n    'uid'                        =\n ['rogasawara'],\n    'mail'                       =\n ['rogasawara@airius.co.jp'],\n    'givenname;lang-ja'          =\n ['\u30ed\u30c9\u30cb\u30fc'],\n    'sn;lang-ja'                 =\n ['\u5c0f\u7b20\u539f'],\n    'cn;lang-ja'                 =\n ['\u5c0f\u7b20\u539f \u30ed\u30c9\u30cb\u30fc'],\n    'title;lang-ja'              =\n ['\u55b6\u696d\u90e8 \u90e8\u9577'],\n    'preferredlanguage'          =\n ['ja'],\n    'givenname'                  =\n ['\u30ed\u30c9\u30cb\u30fc'],\n    'sn'                         =\n ['\u5c0f\u7b20\u539f'],\n    'cn'                         =\n ['\u5c0f\u7b20\u539f \u30ed\u30c9\u30cb\u30fc'],\n    'title'                      =\n ['\u55b6\u696d\u90e8 \u90e8\u9577'],\n    'givenname;lang-ja;phonetic' =\n ['\u308d\u3069\u306b\u30fc'],\n    'sn;lang-ja;phonetic'        =\n ['\u304a\u304c\u3055\u308f\u3089'],\n    'cn;lang-ja;phonetic'        =\n ['\u304a\u304c\u3055\u308f\u3089 \u308d\u3069\u306b\u30fc'],\n    'title;lang-ja;phonetic'     =\n ['\u3048\u3044\u304e\u3087\u3046\u3076 \u3076\u3061\u3087\u3046'],\n    'givenname;lang-en'          =\n ['Rodney'],\n    'sn;lang-en'                 =\n ['Ogasawara'],\n    'cn;lang-en'                 =\n ['Rodney Ogasawara'],\n    'title;lang-en'              =\n ['Sales, Director'],\n];\n\n$ldif = Encoder::encode($data, ['sort' =\n false, 'version' =\n null]);\n\n/*\n$ldif contains:\ndn:: dWlkPXJvZ2FzYXdhcmEsb3U95Za25qWt6YOoLG89QWlyaXVz\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\nuid: rogasawara\nmail: rogasawara@airius.co.jp\ngivenname;lang-ja:: 44Ot44OJ44OL44O8\nsn;lang-ja:: 5bCP56yg5Y6f\ncn;lang-ja:: 5bCP56yg5Y6fIOODreODieODi+ODvA==\ntitle;lang-ja:: 5Za25qWt6YOoIOmDqOmVtw==\npreferredlanguage: ja\ngivenname:: 44Ot44OJ44OL44O8\nsn:: 5bCP56yg5Y6f\ncn:: 5bCP56yg5Y6fIOODreODieODi+ODvA==\ntitle:: 5Za25qWt6YOoIOmDqOmVtw==\ngivenname;lang-ja;phonetic:: 44KN44Gp44Gr44O8\nsn;lang-ja;phonetic:: 44GK44GM44GV44KP44KJ\ncn;lang-ja;phonetic:: 44GK44GM44GV44KP44KJIOOCjeOBqeOBq+ODvA==\ntitle;lang-ja;phonetic:: 44GI44GE44GO44KH44GG44G2IOOBtuOBoeOCh+OBhg==\ngivenname;lang-en: Rodney\nsn;lang-en: Ogasawara\ncn;lang-en: Rodney Ogasawara\ntitle;lang-en: Sales, Director\n*/\n\n\n\nDeserialize a LDIF string into a LDAP entry\n\n\nuse Zend\\Ldap\\Ldif\\Encoder;\n\n$ldif = \ndn:: dWlkPXJvZ2FzYXdhcmEsb3U95Za25qWt6YOoLG89QWlyaXVz\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\nuid: rogasawara\nmail: rogasawara@airius.co.jp\ngivenname;lang-ja:: 44Ot44OJ44OL44O8\nsn;lang-ja:: 5bCP56yg5Y6f\ncn;lang-ja:: 5bCP56yg5Y6fIOODreODieODi+ODvA==\ntitle;lang-ja:: 5Za25qWt6YOoIOmDqOmVtw==\npreferredlanguage: ja\ngivenname:: 44Ot44OJ44OL44O8\nsn:: 5bCP56yg5Y6f\ncn:: 5bCP56yg5Y6fIOODreODieODi+ODvA==\ntitle:: 5Za25qWt6YOoIOmDqOmVtw==\ngivenname;lang-ja;phonetic:: 44KN44Gp44Gr44O8\nsn;lang-ja;phonetic:: 44GK44GM44GV44KP44KJ\ncn;lang-ja;phonetic:: 44GK44GM44GV44KP44KJIOOCjeOBqeOBq+ODvA==\ntitle;lang-ja;phonetic:: 44GI44GE44GO44KH44GG44G2IOOBtuOBoeOCh+OBhg==\ngivenname;lang-en: Rodney\nsn;lang-en: Ogasawara\ncn;lang-en: Rodney Ogasawara\ntitle;lang-en: Sales, Director\n;\n\n$data = Encoder::decode($ldif);\n\n/*\n$data = [\n    'dn'                         =\n 'uid=rogasawara,ou=\u55b6\u696d\u90e8,o=Airius',\n    'objectclass'                =\n [\n        'top',\n        'person',\n        'organizationalPerson',\n        'inetOrgPerson',\n    ],\n    'uid'                        =\n ['rogasawara'],\n    'mail'                       =\n ['rogasawara@airius.co.jp'],\n    'givenname;lang-ja'          =\n ['\u30ed\u30c9\u30cb\u30fc'],\n    'sn;lang-ja'                 =\n ['\u5c0f\u7b20\u539f'],\n    'cn;lang-ja'                 =\n ['\u5c0f\u7b20\u539f \u30ed\u30c9\u30cb\u30fc'],\n    'title;lang-ja'              =\n ['\u55b6\u696d\u90e8 \u90e8\u9577'],\n    'preferredlanguage'          =\n ['ja'],\n    'givenname'                  =\n ['\u30ed\u30c9\u30cb\u30fc'],\n    'sn'                         =\n ['\u5c0f\u7b20\u539f'],\n    'cn'                         =\n ['\u5c0f\u7b20\u539f \u30ed\u30c9\u30cb\u30fc'],\n    'title'                      =\n ['\u55b6\u696d\u90e8 \u90e8\u9577'],\n    'givenname;lang-ja;phonetic' =\n ['\u308d\u3069\u306b\u30fc'],\n    'sn;lang-ja;phonetic'        =\n ['\u304a\u304c\u3055\u308f\u3089'],\n    'cn;lang-ja;phonetic'        =\n ['\u304a\u304c\u3055\u308f\u3089 \u308d\u3069\u306b\u30fc'],\n    'title;lang-ja;phonetic'     =\n ['\u3048\u3044\u304e\u3087\u3046\u3076 \u3076\u3061\u3087\u3046'],\n    'givenname;lang-en'          =\n ['Rodney'],\n    'sn;lang-en'                 =\n ['Ogasawara'],\n    'cn;lang-en'                 =\n ['Rodney Ogasawara'],\n    'title;lang-en'              =\n ['Sales, Director'],\n];\n*/", 
            "title": "Serializing LDAP data to and from LDIF"
        }, 
        {
            "location": "/ldif/#serializing-ldap-data-to-and-from-ldif", 
            "text": "", 
            "title": "Serializing LDAP data to and from LDIF"
        }, 
        {
            "location": "/ldif/#serialize-a-ldap-entry-to-ldif", 
            "text": "use Zend\\Ldap\\Ldif\\Encoder;\n\n$data = [\n    'dn'                         =  'uid=rogasawara,ou=\u55b6\u696d\u90e8,o=Airius',\n    'objectclass'                =  [\n        'top',\n        'person',\n        'organizationalPerson',\n        'inetOrgPerson',\n    ],\n    'uid'                        =  ['rogasawara'],\n    'mail'                       =  ['rogasawara@airius.co.jp'],\n    'givenname;lang-ja'          =  ['\u30ed\u30c9\u30cb\u30fc'],\n    'sn;lang-ja'                 =  ['\u5c0f\u7b20\u539f'],\n    'cn;lang-ja'                 =  ['\u5c0f\u7b20\u539f \u30ed\u30c9\u30cb\u30fc'],\n    'title;lang-ja'              =  ['\u55b6\u696d\u90e8 \u90e8\u9577'],\n    'preferredlanguage'          =  ['ja'],\n    'givenname'                  =  ['\u30ed\u30c9\u30cb\u30fc'],\n    'sn'                         =  ['\u5c0f\u7b20\u539f'],\n    'cn'                         =  ['\u5c0f\u7b20\u539f \u30ed\u30c9\u30cb\u30fc'],\n    'title'                      =  ['\u55b6\u696d\u90e8 \u90e8\u9577'],\n    'givenname;lang-ja;phonetic' =  ['\u308d\u3069\u306b\u30fc'],\n    'sn;lang-ja;phonetic'        =  ['\u304a\u304c\u3055\u308f\u3089'],\n    'cn;lang-ja;phonetic'        =  ['\u304a\u304c\u3055\u308f\u3089 \u308d\u3069\u306b\u30fc'],\n    'title;lang-ja;phonetic'     =  ['\u3048\u3044\u304e\u3087\u3046\u3076 \u3076\u3061\u3087\u3046'],\n    'givenname;lang-en'          =  ['Rodney'],\n    'sn;lang-en'                 =  ['Ogasawara'],\n    'cn;lang-en'                 =  ['Rodney Ogasawara'],\n    'title;lang-en'              =  ['Sales, Director'],\n];\n\n$ldif = Encoder::encode($data, ['sort' =  false, 'version' =  null]);\n\n/*\n$ldif contains:\ndn:: dWlkPXJvZ2FzYXdhcmEsb3U95Za25qWt6YOoLG89QWlyaXVz\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\nuid: rogasawara\nmail: rogasawara@airius.co.jp\ngivenname;lang-ja:: 44Ot44OJ44OL44O8\nsn;lang-ja:: 5bCP56yg5Y6f\ncn;lang-ja:: 5bCP56yg5Y6fIOODreODieODi+ODvA==\ntitle;lang-ja:: 5Za25qWt6YOoIOmDqOmVtw==\npreferredlanguage: ja\ngivenname:: 44Ot44OJ44OL44O8\nsn:: 5bCP56yg5Y6f\ncn:: 5bCP56yg5Y6fIOODreODieODi+ODvA==\ntitle:: 5Za25qWt6YOoIOmDqOmVtw==\ngivenname;lang-ja;phonetic:: 44KN44Gp44Gr44O8\nsn;lang-ja;phonetic:: 44GK44GM44GV44KP44KJ\ncn;lang-ja;phonetic:: 44GK44GM44GV44KP44KJIOOCjeOBqeOBq+ODvA==\ntitle;lang-ja;phonetic:: 44GI44GE44GO44KH44GG44G2IOOBtuOBoeOCh+OBhg==\ngivenname;lang-en: Rodney\nsn;lang-en: Ogasawara\ncn;lang-en: Rodney Ogasawara\ntitle;lang-en: Sales, Director\n*/", 
            "title": "Serialize a LDAP entry to LDIF"
        }, 
        {
            "location": "/ldif/#deserialize-a-ldif-string-into-a-ldap-entry", 
            "text": "use Zend\\Ldap\\Ldif\\Encoder;\n\n$ldif =  dn:: dWlkPXJvZ2FzYXdhcmEsb3U95Za25qWt6YOoLG89QWlyaXVz\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\nuid: rogasawara\nmail: rogasawara@airius.co.jp\ngivenname;lang-ja:: 44Ot44OJ44OL44O8\nsn;lang-ja:: 5bCP56yg5Y6f\ncn;lang-ja:: 5bCP56yg5Y6fIOODreODieODi+ODvA==\ntitle;lang-ja:: 5Za25qWt6YOoIOmDqOmVtw==\npreferredlanguage: ja\ngivenname:: 44Ot44OJ44OL44O8\nsn:: 5bCP56yg5Y6f\ncn:: 5bCP56yg5Y6fIOODreODieODi+ODvA==\ntitle:: 5Za25qWt6YOoIOmDqOmVtw==\ngivenname;lang-ja;phonetic:: 44KN44Gp44Gr44O8\nsn;lang-ja;phonetic:: 44GK44GM44GV44KP44KJ\ncn;lang-ja;phonetic:: 44GK44GM44GV44KP44KJIOOCjeOBqeOBq+ODvA==\ntitle;lang-ja;phonetic:: 44GI44GE44GO44KH44GG44G2IOOBtuOBoeOCh+OBhg==\ngivenname;lang-en: Rodney\nsn;lang-en: Ogasawara\ncn;lang-en: Rodney Ogasawara\ntitle;lang-en: Sales, Director ;\n\n$data = Encoder::decode($ldif);\n\n/*\n$data = [\n    'dn'                         =  'uid=rogasawara,ou=\u55b6\u696d\u90e8,o=Airius',\n    'objectclass'                =  [\n        'top',\n        'person',\n        'organizationalPerson',\n        'inetOrgPerson',\n    ],\n    'uid'                        =  ['rogasawara'],\n    'mail'                       =  ['rogasawara@airius.co.jp'],\n    'givenname;lang-ja'          =  ['\u30ed\u30c9\u30cb\u30fc'],\n    'sn;lang-ja'                 =  ['\u5c0f\u7b20\u539f'],\n    'cn;lang-ja'                 =  ['\u5c0f\u7b20\u539f \u30ed\u30c9\u30cb\u30fc'],\n    'title;lang-ja'              =  ['\u55b6\u696d\u90e8 \u90e8\u9577'],\n    'preferredlanguage'          =  ['ja'],\n    'givenname'                  =  ['\u30ed\u30c9\u30cb\u30fc'],\n    'sn'                         =  ['\u5c0f\u7b20\u539f'],\n    'cn'                         =  ['\u5c0f\u7b20\u539f \u30ed\u30c9\u30cb\u30fc'],\n    'title'                      =  ['\u55b6\u696d\u90e8 \u90e8\u9577'],\n    'givenname;lang-ja;phonetic' =  ['\u308d\u3069\u306b\u30fc'],\n    'sn;lang-ja;phonetic'        =  ['\u304a\u304c\u3055\u308f\u3089'],\n    'cn;lang-ja;phonetic'        =  ['\u304a\u304c\u3055\u308f\u3089 \u308d\u3069\u306b\u30fc'],\n    'title;lang-ja;phonetic'     =  ['\u3048\u3044\u304e\u3087\u3046\u3076 \u3076\u3061\u3087\u3046'],\n    'givenname;lang-en'          =  ['Rodney'],\n    'sn;lang-en'                 =  ['Ogasawara'],\n    'cn;lang-en'                 =  ['Rodney Ogasawara'],\n    'title;lang-en'              =  ['Sales, Director'],\n];\n*/", 
            "title": "Deserialize a LDIF string into a LDAP entry"
        }
    ]
}